<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode_Convert Binary Search Tree to Sorted Doubly Linked List]]></title>
    <url>%2F2019%2F08%2F20%2Fleetcode-ConvertBinarySearchTreetoSortedDoublyLinkedList%2F</url>
    <content type="text"><![CDATA[Convert Binary Search Tree to Sorted Doubly Linked ListConvert a BST to a sorted circular doubly-linked list in-place. Think of the left and right pointers as synonymous to the previous and next pointers in a doubly-linked list.（将二叉搜索树转换为一个有序的双向链表） Example: 1. 中序遍历首先对二叉树进行中序遍历，将遍历后的结果进行指针调整，时间复杂度为O(n)，空间复杂度为O(n)。具体实现过程如下： 1234567891011121314151617181920212223# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def in_order(self, root): if not root: return self.in_order(root.left) self.list.append(root) self.in_order(root.right) def Convert(self, pRootOfTree): if not pRootOfTree: return self.list = [] self.in_order(pRootOfTree) for i, node in enumerate(self.list[:-1]): node.right = self.list[i + 1] self.list[i + 1].left = node return self.list[0] 2. 中序遍历在对二叉树进行中序遍历时进行指针调整，时间复杂度为O(n)，空间复杂度为O(1)。具体实现过程如下： 123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def __init__(self): self.listHead = None self.listTail = None def Convert(self, pRootOfTree): if pRootOfTree==None: return self.Convert(pRootOfTree.left) if self.listHead==None: self.listHead = pRootOfTree self.listTail = pRootOfTree else: self.listTail.right = pRootOfTree pRootOfTree.left = self.listTail self.listTail = pRootOfTree self.Convert(pRootOfTree.right) return self.listHead]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Validate Stack Sequences]]></title>
    <url>%2F2019%2F08%2F20%2Fleetcode-ValidateStackSequences%2F</url>
    <content type="text"><![CDATA[Validate Stack SequencesGiven two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.（判断有效的栈压入、压出序列） Note: 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed is a permutation of popped. pushed and popped have distinct values. Example: 1. 模拟栈构建一个新的栈来模拟栈压入、压出的过程，直到最后栈为空时表示是有效的序列。时间复杂度为O(n)，空间复杂度为O(n)。具体实现过程如下： 12345678910class Solution: def validateStackSequences(self, pushed: List[int], popped: List[int]) -&gt; bool: temp_stack = [] while pushed: top = pushed.pop(0) temp_stack.append(top) while temp_stack and popped and popped[0] == temp_stack[-1]: popped.pop(0) temp_stack.pop() return not temp_stack]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm_Knapsack Problem]]></title>
    <url>%2F2019%2F08%2F10%2Falgorithm-KnapsackProblem%2F</url>
    <content type="text"><![CDATA[Knapsack Problem背包问题 背包问题（Knapsack problem）是一种组合优化的 NP 完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择才能使得物品的总价格最高。 1. 背包问题这个问题是指每个物体的可以拆分，即可以得到单位重量的价值，最终要求选择后的结果使得物品的总价格最高，这种问题最后背包一定会放满，使用贪心算法。具体实现过程如下: 123456789101112131415161718192021weights = [3, 4, 8, 5]values = [7, 4, 3, 8]C = 10n = len(weights)value_per_weights = [(values[i]/weights[i], weights[i]) for i in range(n)]value_per_weights.sort(key=lambda x: x[0], reverse=True)results = [0] * nfor i in range(n): if value_per_weights[i][1] &gt; C: break results[i] = 1 C -= value_per_weights[i][1]if i &lt; n: results[i] = C / value_per_weights[i][1]for value_per_weight, result in zip(value_per_weights, results): print(value_per_weight[1], result) 2. 01背包问题01背包问题是指每个物体都有且只有一个（即选或不选），最终要求选择后的结果使得物品的总价格最高，这种问题最后背包不一定会放满，使用动态规划算法。具体实现过程如下： f[n][C] 表示容量 C 是否可以放置前 i 个物品。 f[i][j] = max( f[i-1][j-weights[i]] + values[i] if j&gt;=weights[i], f[i-1][j]) 1234567891011121314weights = [3, 4, 8, 5]values = [7, 4, 3, 8]C = 10n = len(weights)dp = [[0] * (C+1) for _ in range(n+1)]for i in range(1, n+1): for j in range(C+1): dp[i][j] = max(dp[i][j], dp[i-1][j]) if weights[i-1] &lt;= j: dp[i][j] = max(dp[i][j], dp[i-1][j-weights[i-1]]+values[i-1])return dp[n][C] 3. 非01背包问题非01背包问题是指每个物体都有很多个(无限个)，最终要求选择后的结果使得物品的总价格最高。具体实现过程如下： 123456789101112131415weights = [3, 4, 8, 5]values = [7, 4, 3, 8]C = 10n = len(weights)dp = [[0] * (C+1) for _ in range(n+1)]for i in range(1, n+1): for j in range(C+1): k = 0 while k*weights[i-1] &lt;= j: dp[i][j] = max(dp[i][j], dp[i-1][j-k*weights[i-1]]+k*values[i-1]) k += 1return max(map(max, dp)) 4. 变种之选硬币问题给定一些物品数组和一个目标值，问有多少种可以组成目标的组合数，比如给定物品数组 [2,3,6,7] 和目标值 7 （2种可能）。可以考虑使用动态规划：dp[n][C] 表示从前i中里面组成 C 的组合数，则dp[n][C] = dp[n-1][C] + dp[n-1][C-values[n-1]* 1] + dp[n-1][C-values[n-1]* 2] + … 123456789101112131415values = [2, 3, 6, 7]C = 7n = len(values)dp = [[0] * (C+1) for _ in range(n+1)]dp[0][0] = 1for i in range(1, n+1): for j in range(C+1): k = 0 while k*values[i-1] &lt;= j: dp[i][j] += dp[i - 1][j - k * values[i - 1]]; k += 1return dp[n][C]]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
        <tag>knapsack</tag>
        <tag>back_tracking</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_Perfect Squares]]></title>
    <url>%2F2019%2F06%2F30%2Fleetcode-PerfectSquares%2F</url>
    <content type="text"><![CDATA[Perfect SquaresGiven a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.（将一个正整数分为干个平方数的和，使得平方数个数最少） Example: 1. BFS12345678910111213141516class Solution: def numSquares(self, n: int) -&gt; int: queue = [n] count = 0 while queue: tmp = [] count += 1 for q in queue: i = 1 while i*i &lt;= q: v = q - i*i if v == 0: return count tmp.append(v) i += 1 queue = tmp 2. 动态规划12345678910class Solution: def numSquares(self, n: int) -&gt; int: dp = [1] + [0]*n for i in range(int(n**0.5), 0, -1): s = i**2 for j in range(len(dp)): if dp[j] and j+s &lt; len(dp) and not 0 &lt; dp[j+s] &lt; dp[j] + 1: dp[j+s] = dp[j]+1 return dp[-1] - 1]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>bfs</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_Integer to English Words]]></title>
    <url>%2F2019%2F06%2F30%2Fleetcode-IntegertoEnglishWords%2F</url>
    <content type="text"><![CDATA[Integer to English WordsConvert a non-negative integer to its english words representation. Given input is guaranteed to be less than 2^31 - 1.（读数值） Example: 1. 哈希表12345678910111213141516171819202122232425262728293031323334353637class Solution: def numberToWords(self, num: int) -&gt; str: if num == 0: return "Zero" digits = ["Zero", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"] tens = ["Zero", "Ten", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"] if num &gt;= 1000000000: if num % 1000000000: return self.numberToWords(num // 1000000000) + " Billion " + self.numberToWords(num % 1000000000) else: return self.numberToWords(num // 1000000000) + " Billion" elif num &gt;= 1000000: if num % 1000000: return self.numberToWords(num // 1000000) + " Million " + self.numberToWords(num % 1000000) else: return self.numberToWords(num // 1000000) + " Million" elif num &gt;= 1000: if num % 1000: return self.numberToWords(num // 1000) + " Thousand " + self.numberToWords(num % 1000) else: return self.numberToWords(num // 1000) + " Thousand" elif num &gt;= 100: if num % 100: return self.numberToWords(num // 100) + " Hundred " + self.numberToWords(num % 100) else: return self.numberToWords(num // 100) + " Hundred" elif num &gt;= 20: if num % 10: return tens[num // 10] + ' ' +self.numberToWords(num % 10) else: return tens[num // 10] elif num &gt;= 1: return digits[num] else: return '' 另一种更简洁的方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657num_mapping = &#123; 1: "One", 2: "Two", 3: "Three", 4: "Four", 5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine", 10: "Ten", 11: "Eleven", 12: "Twelve", 13: "Thirteen", 14: "Fourteen", 15: "Fifteen", 16: "Sixteen", 17: "Seventeen", 18: "Eighteen", 19: "Nineteen"&#125;prefixes = [ (1000000000, "Billion"), (1000000, "Million"), (1000, "Thousand"), (100, "Hundred"), (90, "Ninety"), (80, "Eighty"), (70, "Seventy"), (60, "Sixty"), (50, "Fifty"), (40, "Forty"), (30, "Thirty"), (20, "Twenty")]class Solution: def numberToWords(self, num: int) -&gt; str: if num in num_mapping: return num_mapping[num] elif num == 0: return "Zero" words = [] for size, text in prefixes: size_count = num // size num = num % size if size_count: if size &gt;= 100: words.append(self.numberToWords(size_count)) words.append(text) if num in num_mapping: words.append(num_mapping[num]) return " ".join(words)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>hash table</tag>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_Ugly Number II]]></title>
    <url>%2F2019%2F06%2F30%2Fleetcode-UglyNumberII%2F</url>
    <content type="text"><![CDATA[Ugly Number IIWrite a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.（第 n 个丑数） Note: 1 is typically treated as an ugly number. n does not exceed 1690. Example: 1. 动态规划任何一个新的丑数可以看做是一个旧的丑数乘以 2，3，5 得到的。因此可以设置三个指针，每当因为乘以一个因子而增加一个丑数时，相应的指针就后移，具体实现过程如下： 1234567891011121314151617class Solution: def nthUglyNumber(self, n: int) -&gt; int: ugly_list = [1] p_2, p_3, p_5 = 0, 0, 0 while len(ugly_list) &lt; n: num_2, num_3, num_5 = ugly_list[p_2]*2, ugly_list[p_3]*3, ugly_list[p_5]*5 min_num = min(num_2, num_3, num_5) if num_2 == min_num: p_2 += 1 if num_3 == min_num: p_3 += 1 if num_5 == min_num: p_5 +=1 ugly_list.append(min_num) return ugly_list[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm_Closest Pair of Points]]></title>
    <url>%2F2019%2F06%2F30%2Falgorithm-ClosestPairofPoints%2F</url>
    <content type="text"><![CDATA[Closest Pair of Points（平面最近点对） 给定平面上n个点，找其中的一对点，使得在n个点的所有点对中，该点对的距离最小。 1. 暴力轮循直接计算每两个点之间的距离，然后就可以确定距离最小的两个点。其时间复杂度为 O(n*2) 2. 分治法基本思路是将点集合平均分为两份，分别计算两个子集合中的最近点对。此方法重点在于分治算法的合并过程，即最近点对分别存在于两个集合中。其时间复杂度是 O(nlogn) ，具体算法步骤如下： 对所有点从小到大排序，以 x 为第一关键词，y 为第二关键字； 将所有点按 x = mid 坐标分成左右两部分； 递归求解左右两部分中的最近距离，并取最小值min_d = min{min_left，min_right}； 以 x = mid 划分 x = mid - min_d 和 x = mid + min_d 的区域，则若最近点对分别存在于两个集合中，必须在此范围内； 1）其中对于在 [mid - min_d, mid] 的点 p(x_p, y_p)，不需要与所有 [mid, mid + min_d] 的点计算距离，而是 x in [mid, mid + min_d], y in [y_p - min_d, y_p + min_d] 范围内的点计算即可。主要时间复杂度是排序的时间复杂度，即 O(nlogn)，具体实现过程如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import mathclass Point(object): """docstring for Point""" def __init__(self, x, y): self.x = x self.y = ydef point_distance(p, q): return math.sqrt(pow(p.x-q.x, 2) + pow(p.y-q.y, 2))def candidatePoint(p, points, min_d, med_x): for q in points: if q.x &lt; med_x - min_d: continue if q.x &gt; med_x + min_d: break if q.y &gt;= p.y-min_d and q.y &lt;= p.y+min_d: yield qdef combine(points, n, min_d, med_x): final_min = min_d for p in points[:n//2]: if p.x &lt; med_x - min_d: continue for q in candidatePoint(p, points[n//2:], min_d, med_x): final_min = min(point_distance(p, q), final_min) return final_mindef divide(points): n = len(points) if n &lt;= 1: return float('inf') elif n == 2: return point_distance(points[0], points[1]) else: points=sorted(points, key=lambda x:([x.x, x.y])) min_left = divide(points[:n//2]) min_right = divide(points[n//2:]) med_x = (points[n//2].x + points[-n//2-1].x)/2 min_d = min(min_left, min_right) return combine(points, n, min_d, med_x)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>divide and conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Different Ways to Add Parentheses]]></title>
    <url>%2F2019%2F06%2F24%2FLeetCode-DifferentWaystoAddParentheses%2F</url>
    <content type="text"><![CDATA[Different Ways to Add ParenthesesGiven a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.（不同的加括号方式使得运算结果不一致） Example: 1. 分治法这道题比较直观的是使用分治法分别解决符号的左边和右边的计算结果。其中需要单独考虑的是当字符串中不存在符号时，应该直接返回该字符串的表示的数值。其中，也可以在开始实现使用 isdigit() 判断。具体实现过程如下： 12345678910111213141516171819202122class Solution: def diffWaysToCompute(self, input: str) -&gt; List[int]: if len(input) == 1: return [int(input)] # if input.isdigit(): # return [int(input)] results = [] for i, c in enumerate(input): if c in '+-*': for a in self.diffWaysToCompute(input[:i]): for b in self.diffWaysToCompute(input[i+1:]): if c == '+': results.append(a+b) elif c == '-': results.append(a-b) else: results.append(a*b) # 当字符串中不存在符号时，应该直接返回该字符串的表示的数值 if not results: return [int(input)] return results]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>divide and conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Sliding Window Maximum]]></title>
    <url>%2F2019%2F06%2F21%2FLeetCode-SlidingWindowMaximum%2F</url>
    <content type="text"><![CDATA[Sliding Window MaximumGiven an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.（寻找大小为 k 的滑动窗口中的最大值） Example: 1.常规思路遍历数组，每次计算最大值，时间复杂度为O(N*K), 实际操作中会 TLE. 2. 最大堆堆分为最小堆和最大堆，是一种完全二叉树的结构，最小（大）堆的每个节点均不大（小）于为其孩子节点的值。 1234567891011121314151617import heapqclass Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: if not nums: return [] heap, results = [], [] for i, n in enumerate(nums): while heap and heap[0][1] + k &lt;= i: heapq.heappop(heap) # 默认为最小堆，并根据push的第一个值排序，因此push (-n, i) heapq.heappush(heap, (-n, i)) if i &gt;= k-1: results.append(-heap[0][0]) return results 3. 双端队列双端队列类似于一个list，但是可以对两段都进行加入或删除操作。 使用双端队列，队列元素降序排序，队首元素为所求最大值。滑动窗口右移，每次窗口右移的时候需要判断当前的最大值是否在有效范围，若不在，则需要将其从队列中删除。若出现的元素比队尾（最小元素）大，此时移除比起小的数。时间复杂度为 O(n)，空间复杂度为 O(k)，具体实现过程如下： 1234567891011121314151617181920from collections import deque class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: if not nums: return [] q = deque() results = [] for i in range(len(nums)): while q and q[0] + k &lt;= i: q.popleft() while q and nums[i] &gt;= nums[q[-1]]: q.pop() q.append(i) if i &gt;= k-1: results.append(nums[q[0]]) return results 应用：构造哈夫曼树，任务调度算法]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>heap</tag>
        <tag>sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Summary Ranges]]></title>
    <url>%2F2019%2F06%2F21%2FLeetCode-SummaryRanges%2F</url>
    <content type="text"><![CDATA[Summary RangesGiven a sorted integer array without duplicates, return the summary of its ranges.（将数组中连续的范围合并） Example: 1. 设置标志位 left具体实现过程如下： 123456789101112131415161718192021222324class Solution: def summaryRanges(self, nums: List[int]) -&gt; List[str]: n = len(nums) if not n: return [] results = [] left = -1 for i in range(n-1): if nums[i] == nums[i+1] - 1: if left == -1: left = i else: if left == -1: results.append(str(nums[i])) else: results.append("%s-&gt;%s"%(str(nums[left]), str(nums[i]))) left = -1 if left == -1: results.append(str(nums[n-1])) else: results.append("%s-&gt;%s"%(str(nums[left]), str(nums[n-1]))) return results 2. 直接统计range在遍历数组的过程中不断地更新统计中range的右界，具体实现过程如下： 1234567def summaryRanges(self, nums): ranges = [] for n in nums: if not ranges or n &gt; ranges[-1][-1] + 1: ranges += [], ranges[-1][1:] = n, return ['-&gt;'.join(map(str, r)) for r in ranges]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Combination Sum III]]></title>
    <url>%2F2019%2F06%2F06%2FLeetCode-CombinationSumIII%2F</url>
    <content type="text"><![CDATA[Combination Sum IIIFind all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.（从1-9中选取k个数的和为n） Note: All numbers will be positive integers. The solution set must not contain duplicate combinations. Example: 1. 回溯法12345678910111213class Solution: def back_tracking(self, list, i, k, count): if count == 0 and k == 0: self.results.append(list) for j in range(i, 10): self.back_tracking(list+[j], j+1, k-1, count-j) def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]: self.results = [] self.back_tracking([], 1, k, n) return self.results]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Kth Largest Element in an Array]]></title>
    <url>%2F2019%2F06%2F05%2FLeetCode-KthLargestElementinanArray%2F</url>
    <content type="text"><![CDATA[Kth Largest Element in an ArrayFind the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.(数组定位第k大的元素) Note:You may assume k is always valid, 1 ≤ k ≤ array’s length. Example: 1. 堆1234567import heapqclass Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: heapq.heapify(nums) nlarge = heapq.nlargest(k, nums) return nlarge[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>divide and conquer</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Shortest Palindrome]]></title>
    <url>%2F2019%2F06%2F05%2FLeetCode-ShortestPalindrome%2F</url>
    <content type="text"><![CDATA[Shortest PalindromeGiven a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.（在字符串前面增加字符使其为回文序列） Example: 1. KMP算法首先要找到s的最长回文前缀s1，剩余部分为s2，那么将s2反转和原s串拼接在一起，即可得到要求的回文串。这里用到 KMP 算法的 next 数组的求最长回文前缀s1，设置一个字符串tmp = s1 + s2 + ‘#’ + s2’ + s1’，具体实现过程如下： 123456789101112131415class Solution: def shortestPalindrome(self, s: str) -&gt; str: n = len(s) if n &lt;= 1: return s tmp = s + '#' + s[::-1] k = 0 next = [0 for i in range(len(tmp))] for i in range(1, len(tmp)): while k &gt; 0 and tmp[i] != tmp[k]: k = next[k-1] if tmp[i] == tmp[k]: k += 1 next[i] = k return s[:next[-1]-1:-1] + s]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_House Robber II]]></title>
    <url>%2F2019%2F06%2F05%2FLeetCode-HouseRobberII%2F</url>
    <content type="text"><![CDATA[House Robber IIYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.（圆环数组中不相邻数组成的和最大） Example: 1. 动态规划这道题是之前那道 House Robber 的拓展，但是现在房子排成了一个圆圈，则如果抢了第一家，就不能抢最后一家，因为首尾相连了，所以第一家和最后一家只能抢其中的一家，或者都不抢，那我们这里变通一下，如果我们把第一家和最后一家分别去掉，各算一遍能抢的最大值，然后比较两个值取其中较大的一个即为所求。那我们只需参考之前的 House Robber 中的解题方法，然后调用两边取较大值，具体实现过程如下： 123456789101112131415161718class Solution: def rob_list(self, nums): before_before, before = 0, 0 for i in range(0, len(nums)): temp = before before = max(before_before + nums[i], before) before_before = temp return max(before_before, before) def rob(self, nums: List[int]) -&gt; int: if len(nums) == 1: return nums[0] left_max = self.rob_list(nums[1:]) right_max = self.rob_list(nums[:-1]) return max(left_max, right_max)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Word Search II]]></title>
    <url>%2F2019%2F06%2F05%2FLeetCode-WordSearchII%2F</url>
    <content type="text"><![CDATA[Word Search IIGiven a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.（矩阵中进行一组词语搜索） Example: 1. 回溯法 / DFS根据 Word Search 中的方法，可以直接对数组中的每一个 word 都进行一次 DFS，但是这样会造成很大的时间复杂度 O(K*M*N*M*N)（K 表示词语个数，M 为矩阵行数， N 为矩阵列数）。因此，可以考虑使用字典树首先来表示这 K 个 word，这样可以一次的找出所有的 word。具体实现过程如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import collectionsclass TireNode(object): def __init__(self): self.children = collections.defaultdict(TireNode) self.is_word = Falseclass Tire(object): def __init__(self): self.root = TireNode() def add(self, word): current = self.root for w in word: current = current.children[w] current.is_word = True def search(self, word): current = self.root for w in word: current = current.children.get(w) if not current: return False return current.iswordclass Solution: def dfs(self, board, p_word_trie, results, word, m, n, i, j): if i &lt; 0 or i &gt;= m or j &lt; 0 or j &gt;= n: return w = board[i][j] board[i][j] = '0' word += w current = p_word_trie.children.get(w) if current: if current.is_word: results.add(word) self.dfs(board, current, results, word, m, n, i-1, j) self.dfs(board, current, results, word, m, n, i+1, j) self.dfs(board, current, results, word, m, n, i, j-1) self.dfs(board, current, results, word, m, n, i, j+1) board[i][j] = w word = word[:-1] def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]: if not words: return [] if not board or not board[0]: return [] word_tire = Tire() for word in words: word_tire.add(word) results = set() m, n = len(board), len(board[0]) for i in range(m): for j in range(n): self.dfs(board, word_tire.root, results, '', m, n, i, j) return list(results)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>trie</tag>
        <tag>hard</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Add and Search Word - Data structure design]]></title>
    <url>%2F2019%2F06%2F03%2FLeetCode-AddandSearchWord-Datastructuredesign%2F</url>
    <content type="text"><![CDATA[Add and Search Word - Data structure designDesign a data structure that supports the following two operations. search(word) can search a literal word or a regular expression string containing only letters a-z or .. . means it can represent any one letter.（设计一种数据结构支持正则查询） 12void addWord(word)bool search(word) Example: 1. 回溯法由于包含正则项的匹配，使用回溯法，回溯法一般通过 DFS 完成，具体实现过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import collectionsclass Node: def __init__(self): self.children = collections.defaultdict(Node) self.is_word = Falseclass WordDictionary: def __init__(self): """ Initialize your data structure here. """ self.root = Node() def addWord(self, word: str) -&gt; None: """ Adds a word into the data structure. """ current = self.root for w in word: current = current.children[w] current.is_word = True def dfs(self, current, word, i): if i == len(word): return current.is_word w = word[i] if w == '.': for child in current.children: if current.children[child] and self.dfs(current.children[child], word, i+1): return True return False else: if not current.children.get(w): return False else: return self.dfs(current.children[w], word, i+1) def search(self, word: str) -&gt; bool: """ Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. """ return self.dfs(self.root, word, 0) # Your WordDictionary object will be instantiated and called as such:# obj = WordDictionary()# obj.addWord(word)# param_2 = obj.search(word) 2. 字典由于.能切只能匹配一个字符，因此字符串的长度是恒定的，因此可以根据字符串的长度来进行哈希，具体实现过程如下： 12345678910111213141516171819202122232425262728293031323334353637383940import collectionsclass WordDictionary: def __init__(self): """ Initialize your data structure here. """ self.word_dict = collections.defaultdict(list) def addWord(self, word: str) -&gt; None: """ Adds a word into the data structure. """ if word: self.word_dict[len(word)].append(word) def search(self, word: str) -&gt; bool: """ Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. """ if not word: return False if '.' not in word: if word in self.word_dict[len(word)]: return True for v in self.word_dict[len(word)]: match = True # match xx.xx.x with yyyyyyy for i, ch in enumerate(word): if ch != v[i] and ch != '.': match = False break if match: return True return False # Your WordDictionary object will be instantiated and called as such:# obj = WordDictionary()# obj.addWord(word)# param_2 = obj.search(word)]]></content>
      <tags>
        <tag>medium</tag>
        <tag>backtracking</tag>
        <tag>design</tag>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Course Schedule II]]></title>
    <url>%2F2019%2F06%2F03%2FLeetCode-CourseScheduleII%2F</url>
    <content type="text"><![CDATA[Course Schedule IIThere are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]. Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.（课程清单，给出具体的结果） Example: 1. 拓扑排序-BFS根据 “Course Schedule” 的步骤可以得出具体的结果，时间复杂度为O(n)，空间复杂度为O(n)。具体实现过程如下： 12345678910111213141516171819202122232425262728293031import collectionsclass Solution: def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]: graph = collections.defaultdict(list) indegrees = collections.defaultdict(int) order_list = [] for u, v in prerequisites: graph[v].append(u) indegrees[u] += 1 queue = [u for u in range(numCourses) if indegrees[u] == 0] if not queue: return [] while queue: v = queue[0] order_list.append(v) for u in graph[v]: indegrees[u] -= 1 if indegrees[u] == 0: queue.append(u) queue.remove(v) for u in range(numCourses): if indegrees[u] != 0: return [] return order_list 2. 拓扑排序-DFS同样地，时间复杂度为O(n)，空间复杂度为O(n)。具体实现过程如下： 12345678910111213141516171819202122232425262728class Solution: def dfs(self, graph, order_list, visited, i): if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in graph[i]: if not self.dfs(graph, order_list, visited, j): return False visited[i] = 2 order_list.append(i) return True def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]: graph = collections.defaultdict(list) visited = [0]*numCourses order_list = [] for u, v in prerequisites: graph[v].append(u) for i in range(numCourses): if not self.dfs(graph, order_list, visited, i): return [] order_list.reverse() return order_list]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
        <tag>graph</tag>
        <tag>topological-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Minimum Size Subarray Sum]]></title>
    <url>%2F2019%2F06%2F03%2FLeetCode-MinimumSizeSubarraySum%2F</url>
    <content type="text"><![CDATA[Minimum Size Subarray SumGiven an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.（最小长度的子数组的和大于特定的值） Example: 1. 两个指针定义两个指针 left 和 right，分别记录子数组的左右的边界位置。让 right 向右移，直到子数组和大于等于给定值或者 right 达到数组末尾，此时我们更新最短距离，并且将 left 像右移一位，然后再 sum 中减去移去的值，然后重复上面的步骤，直到 right 到达末尾，且 left 到达临界位置，即要么到达边界，要么再往右移动，和就会小于给定值。时间复杂度为 O(n)，具体实现过程如下： 12345678910111213141516171819class Solution: def minSubArrayLen(self, s, nums): if not nums: return 0 n = len(nums) left, right, min_len, sum = 0, 0, n + 1, 0 while right &lt; n: while sum &lt; s and right &lt; n: sum += nums[right] right += 1 while sum &gt;= s: min_len = min(min_len, right-left) sum -= nums[left] left += 1 if min_len == n + 1: return 0 return min_len 2. 二分查找由于一般的二分查找都是针对有序的数组进行的，而当前数组是无序的而且我们不能改变数组中元素的位置。因此构建一个新的数组 sum，sum[i]表示 nums[:i] 子数组的和。这个一定是递增的，因此我们可以对其进行二分查找，时间复杂度为 O(nlogn)。具体实现过程如下： 1234567891011121314151617181920212223242526272829class Solution: def binary_search(self, sums, key, left, right): while left &lt;= right: mid = (left + right) // 2 if sums[mid] &gt;= key: right = mid - 1 else: left = mid + 1 return left def minSubArrayLen(self, s, nums): if not nums: return 0 n = len(nums) min_len = n + 1 sums = [0] * (n+1) for i in range(n): sums[i+1] = sums[i] + nums[i] for i in range(n+1): index = self.binary_search(sums, s + sums[i], i+1, n) if index == n + 1: break min_len = min(min_len, index - i) if min_len == n + 1: return 0 return min_len]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Implement Trie (Prefix Tree)]]></title>
    <url>%2F2019%2F06%2F03%2FLeetCode-ImplementTrie%2F</url>
    <content type="text"><![CDATA[Implement Trie (Prefix Tree)Implement a trie with insert, search, and startsWith methods.(实现字典树以及相关功能函数) Example: 字典树（前缀树）实现需要注意的是，字典树的根节点不包含字符。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import collectionsclass Node: def __init__(self): self.children = collections.defaultdict(Node) self.isword = Falseclass Trie: def __init__(self): """ Initialize your data structure here. """ self.root = Node() def insert(self, word: str) -&gt; None: """ Inserts a word into the trie. """ current = self.root for w in word: current = current.children[w] current.isword = True def search(self, word: str) -&gt; bool: """ Returns if the word is in the trie. """ current = self.root for w in word: current = current.children.get(w) if not current: return False return current.isword def startsWith(self, prefix: str) -&gt; bool: """ Returns if there is any word in the trie that starts with the given prefix. """ current = self.root for w in prefix: current = current.children.get(w) if not current: return False return True# Your Trie object will be instantiated and called as such:# obj = Trie()# obj.insert(word)# param_2 = obj.search(word)# param_3 = obj.startsWith(prefix)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>design</tag>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Course Schedule]]></title>
    <url>%2F2019%2F06%2F03%2FLeetCode-CourseSchedule%2F</url>
    <content type="text"><![CDATA[Course ScheduleThere are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]. Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?（课程清单） Example: 不同的课程可能存在前置课程，要求能否在不存在矛盾的情况下安排这些课程（如上述1必须在0的前面），这实质上是一个在有向图中判断是否存在圆环的过程，具体的课程安排则是一个拓扑排序的过程。 如果一个有向图的任意顶点都无法通过一些有向边回到自身，那么称这个有向图为有向无环图(Directed Acyclic Graph, DAG)。 拓扑排序是将有向无环图G的所有顶点排成一个线性序列，使得对图G中的任意两个顶点u、v，如果存在边u-&gt;v，那么在序列中u一定在v前面。这个序列又被称为拓扑序列。 1. 拓扑排序-BFS这里我们需要用到一个图里入度的概念，在初始的图中，入度为0的点，即是课程中最基础的课程（需要先修），在找到图中所有入度为0的点以后，将它们依次放入一个队列中，每次循环从队列头提取一个点，然后将这个点放入图中查询，查出哪些点被这个点所指向，并依次将这些点的入度减1，直观上的看的话，即是一个删除一个入度为0的点的操作，每次减1时，检测其他节点的入度，若出现新的入度为0的点，将其加入队列，循环往复，直到队列为空为止。 循环结束后，再次检查每个节点的入度，若该图是拓扑有序的，则在循环操作中，所有的入度都会变为0。若不是拓扑有序的，则还会有入度不为0的点，即存在环。时间复杂度是O(N^2)，空间复杂度是O(N)。具体实现过程如下： 1234567891011121314151617181920212223242526272829import collectionsclass Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool: graph = collections.defaultdict(list) indegrees = collections.defaultdict(int) for u, v in prerequisites: graph[v].append(u) indegrees[u] += 1 queue = [u for u in range(numCourses) if indegrees[u] == 0] if not queue: return False while queue: v = queue[0] for u in graph[v]: indegrees[u] -= 1 if indegrees[u] == 0: queue.append(u) queue.remove(v) for u in range(numCourses): if indegrees[u] != 0: return False return True 2. 拓扑排序-DFS同样是拓扑排序，但是换了个做法，使用DFS。这个方法是，我们每次找到一个新的点，判断从这个点出发是否有环，具体做法是使用一个 visited 数组： 当 visited[i] 值为0，说明还没判断这个点； 当 visited[i] 值为1，说明当前的循环正在判断这个点； 当 visited[i] 值为2，说明已经判断过这个点，含义是从这个点往后的所有路径都没有环，认为这个点是安全的。 那么，我们对每个点出发都做这个判断，检查这个点出发的所有路径上是否有环， 如果判断过程中找到了当前的正在判断的路径（visited[i] == 1），说明有环； 如果找到了已经判断正常的点（visited[i] == 2），说明往后都不可能存在环，所以认为当前的节点也是安全的； 如果当前点是未知状态，那么先把当前点标记成正在访问状态visited[i] = 1），然后找后续的节点，直到找到安全的节点为止。最后如果到达了无路可走的状态，说明当前节点是安全的。 时间复杂度是O(N)，空间复杂度是O(N)。具体实现过程如下： 12345678910111213141516171819202122232425262728import collectionsclass Solution: def dfs(self, graph, visited, i): if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in graph[i]: if not self.dfs(graph, visited, j): return False visited[i] = 2 return True def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool: graph = collections.defaultdict(list) for u, v in prerequisites: graph[v].append(u) visited = [0] * numCourses for i in range(numCourses): if not self.dfs(graph, visited, i): return False return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
        <tag>graph</tag>
        <tag>topological-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Reverse Linked List]]></title>
    <url>%2F2019%2F06%2F03%2FLeetCode-ReverseLinkedList%2F</url>
    <content type="text"><![CDATA[Reverse Linked ListReverse a singly linked list.（翻转链表） Note:A linked list can be reversed either iteratively or recursively. Could you implement both? Example: 1. 迭代法构建一个头结点，在遍历链表的过程中不断地采用头插法即可翻转链表。具体实现过程如下： 123456789101112131415161718# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head: ListNode) -&gt; ListNode: new_head = ListNode(0) p = head while p: tmp = p.next p.next = new_head.next new_head.next = p p = tmp return new_head.next 2. 递归法递归的翻转后面的字符串，然后将当前的头结点放在最尾部，具体实现过程如下： 12345678910111213141516# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head new_head = self.reverseList(head.next) head.next.next = head head.next = None return new_head]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Isomorphic Strings]]></title>
    <url>%2F2019%2F05%2F12%2FLeetCode-IsomorphicStrings%2F</url>
    <content type="text"><![CDATA[Isomorphic StringsGiven two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.（判断是否为同构字符串） Example: 1. 哈希表用哈希表保存相同字符的index。具体实现过程如下： 1234567891011121314151617from collections import defaultdict class Solution: def isIsomorphic(self, s: str, t: str) -&gt; bool: if not s: return True map_s, map_t = defaultdict(list), defaultdict(list) for i in range(len(s)): map_s[s[i]].append(i) map_t[t[i]].append(i) if map_s[s[i]] != map_t[t[i]]: return False return True 2. zip &amp; 集合首先判断组成两个字符串的字符的数目是否相同，然后使用 zip 函数判断字符串相同位置的字符组合是否相同。具体实现过程如下： 123456class Solution: def isIsomorphic(self, s: str, t: str) -&gt; bool: if(len(set(zip(s,t)))==len(set(s))==len(set(t))): return True else: return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Number of Islands]]></title>
    <url>%2F2019%2F05%2F11%2FLeetCode-NumberofIslands%2F</url>
    <content type="text"><![CDATA[Number of IslandsGiven a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.（求岛屿的个数） Example: 1. DFS遍历1234567891011121314151617181920212223class Solution: def dfs(self, i, j): if 0 &lt;= i &lt; self.m and 0 &lt;= j &lt; self.n and self.grid[i][j] == '1': self.grid[i][j] = '0' self.dfs(i+1, j) self.dfs(i-1, j) self.dfs(i, j+1) self.dfs(i, j-1) def numIslands(self, grid: List[List[str]]) -&gt; int: if not grid: return 0 self.m, self.n = len(grid), len(grid[0]) self.grid = grid count = 0 for i in range(self.m): for j in range(self.n): if self.grid[i][j] == '1': self.dfs(i, j) count += 1 return count]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Binary Tree Right Side View]]></title>
    <url>%2F2019%2F05%2F11%2FLeetCode-BinaryTreeRightSideView%2F</url>
    <content type="text"><![CDATA[Binary Tree Right Side ViewGiven a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.（二叉树的右视图） Example: 1. BFS按层遍历12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def rightSideView(self, root: TreeNode) -&gt; List[int]: if not root: return [] result = [] stack = [root] while stack: result.append(stack[0].val) new_stack = [] for node in stack: if node.right: new_stack.append(node.right) if node.left: new_stack.append(node.left) stack = new_stack return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_House Robber]]></title>
    <url>%2F2019%2F05%2F10%2FLeetCode-HouseRobber%2F</url>
    <content type="text"><![CDATA[House RobberGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police (the robber list cannot be adjacent).（数组中不相邻数组成的和最大） Example: 1. 动态规划为了保证不存在相邻的数，可以维护两个变量表示a_(n-2) 和 a_(n-1)，于是就有a_n = max(a_(n-2) + nums[n], a_(n-1))。具体实现过程如下： 12345678910class Solution: def rob(self, nums: List[int]) -&gt; int: before_before, before = 0, 0 for i in range(len(nums)): temp = before before = max(before_before + nums[i], before) before_before = temp return max(before_before, before)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bash Script]]></title>
    <url>%2F2019%2F05%2F10%2FBashScript%2F</url>
    <content type="text"><![CDATA[Linux 终端指令总结。 1. 词频统计Example: tr : -s，连续的字符（空格）缩减为1个；字符替换（空格 -&gt; 换行）。 uniq -c: 计算相同的行的数目 sort -r: 降序排序 awk: 从标准输入中选择字段输出 1cat words.txt | tr -s ' ' '\n' | sort | uniq -c | sort -r | awk '&#123;print $2, $1&#125;' 2. 输出第 N 行Example: sed : -n，只打印匹配的行 1sed -n 10p file.txt]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Reverse Bits]]></title>
    <url>%2F2019%2F04%2F16%2FLeetCode-ReverseBits%2F</url>
    <content type="text"><![CDATA[Reverse BitsReverse bits of a given 32 bits unsigned integer.（翻转2进制无符号数表示） Example: 1. 转换为字符串将输入的数值用format函数转换为32位的二进制的形式，然后翻转后再转换为2进制即可。具体实现如下： 123456class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): string_n = '&#123;:032b&#125;'.format(n) return int(string_n[::-1], 2) Note: 这里可以总结的是format函数可以转换进制并表示，这里的b表示二进制，032表示32位表示，不足的位置补0。 2. 位操作按位操作，将数值的2进制表示从右向左逐渐加载result的后面。具体实现过程如下： 12345678910class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): result = 0 for i in range(32): result &lt;&lt;= 1 result |= (n&amp;1) n &gt;&gt;= 1 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Rotate Array]]></title>
    <url>%2F2019%2F04%2F15%2FLeetCode-RotateArray%2F</url>
    <content type="text"><![CDATA[Rotate ArrayGiven an array, rotate the array to the right by k steps, where k is non-negative.（翻转数组） Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? Example: 1. 数组拼接根据上面的例子我们可以总结出如下规律，在经历了 k 次旋转之后的数组为原始数组的 [n-k:] 和 [:n-k] 两个数组拼接在一起的结果。其时间复杂度为 O(n) ，空间复杂度为 O(1) 。具体实现过程如下： 123456789class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: """ Do not return anything, modify nums in-place instead. """ n = len(nums) k = k % n nums[:] = nums[n-k:] + nums[:n-k] # nums[:] = nums[-k:] + nums[:-k] 2. 3次旋转数组根据上面的例子我们可以总结出如下规律，在经历了 k 次旋转之后的数组为 1-原始数组全部旋转，2-前k项旋转，3-后n-k项旋转的结果。其时间复杂度为 O(n) ，空间复杂度为 O(1) 。具体实现过程如下： 12345678910111213141516class Solution: def reverse(self, nums, start, end): while start &lt; end: nums[start], nums[end] = nums[end], nums[start] start, end = start + 1, end - 1 def rotate(self, nums: List[int], k: int) -&gt; None: """ Do not return anything, modify nums in-place instead. """ if k is None or k &lt;= 0: return k, end = k % len(nums), len(nums) - 1 self.reverse(nums, 0, end - k) self.reverse(nums, end - k + 1, end) self.reverse(nums, 0, end)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Best Time to Buy and Sell Stock IV]]></title>
    <url>%2F2019%2F04%2F10%2FLeetCode-BestTimetoBuyandSellStockIV%2F</url>
    <content type="text"><![CDATA[Best Time to Buy and Sell Stock IVSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions.（股票收益） Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example: 1. 动态规划结合前几次的买卖股票的问题，这次的区别在于交易的次数至多 k 次。如此一来，我们一定可以根据前交易 k-1 次的交易来推导出再增加一交易的最大收入，具体实现过程如下： 12345678910111213141516171819202122232425262728class Solution: def maxProfit(self, k: int, prices: List[int]) -&gt; int: n = len(prices) if n &lt; 2: return 0 # k足够大，能够赢取所有的收益 if k &gt;= n // 2: return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j &gt; 0) # 在n天内进行k次交易的最大收益值 global_max = [[0] * n for _ in range(k+1)] for i in range(1, k+1): # n天内的最大收益 local_max = [0] * n for j in range(1, n): profit = prices[j] - prices[j-1] # 1. 在j-1天进行i-1次的最大收益 + 第j-1天买入&amp;第j天卖掉的收益 # 2. 在j-1天进行i-1次的最大收益 + 第j天买入&amp;第j天卖掉的收益(0) # 3. 前j-1天的最大收益 + 第j-1天买入&amp;第j天卖掉的收益 local_max[j] = max(global_max[i-1][j-1] + profit, global_max[i-1][j-1], local_max[j-1]+profit) # 1. 在j-1天进行i次的最大收益 # 2. 前j天的最大收益 global_max[i][j] = max(global_max[i][j-1], local_max[j]) return global_max[-1][-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Repeated DNA Sequences]]></title>
    <url>%2F2019%2F04%2F07%2FLeetCode-RepeatedDNASequences%2F</url>
    <content type="text"><![CDATA[Repeated DNA SequencesAll DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.（找出字符串中长度为10的重复出现的子串） Example: 1. 哈希表遍历字符串，记录每个长度为10的子串出现的次数，具体实现过程如下: 12345678910from collections import defaultdictclass Solution: def findRepeatedDnaSequences(self, s: str) -&gt; List[str]: substring_dict = defaultdict(int) for i in range(len(s) - 9): substring_dict[s[i:i+10]] += 1 return [string for string in substring_dict if substring_dict[string] &gt; 1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>hash table</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Largest Number]]></title>
    <url>%2F2019%2F04%2F07%2FLeetcode-LargestNumber%2F</url>
    <content type="text"><![CDATA[Largest NumberGiven a list of non negative integers, arrange them such that they form the largest number.（字符串拼接在一起为最大数） Example: 1. sort &amp; key看到这个题目最直观的想法是将这些数字首先按照最高位排序，然后是第二高位，依次排序下去。由于每个数字长度不确定，如何进行排序也不是很明确。因此看到了题目给的解法是重载了sort函数的参数key的类中的__le__函数。（因为sort默认的是升序排列，所以只需要重载__le__即可） 具体实现过程如下： class LargeNumKey(str): def __lt__(x, y): return x+y &gt; y+x class Solution: def largestNumber(self, nums: List[int]) -&gt; str: largest_num = "".join(sorted(map(str, nums), key=LargeNumKey)) return '0' if largest_num[0] == '0' else largest_num]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Dungeon Game]]></title>
    <url>%2F2019%2F04%2F07%2FLeetcode-DungeonGame%2F</url>
    <content type="text"><![CDATA[Dungeon GameThe demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.（勇士解救公主需要的最低能量） In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess. Example: For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN. 1. 动态规划为了保证勇士能够顺利到达公主的位置，所以每个位置的最低能量值都是1。从矩阵的右下角出发不断往回回溯，需要每个方格需要的最小能量值。具体的动态规划递推表达式如下： 1234567891011121314151617class Solution: def calculateMinimumHP(self, dungeon: List[List[int]]) -&gt; int: m, n = len(dungeon), len(dungeon[0]) dp = [[0]* (n) for _ in range(m)] for i in range(m-1, -1, -1): for j in range(n-1, -1, -1): if i == m-1 and j == n-1: dp[i][j] = max(1, 1 - dungeon[i][j]) elif i == m-1: dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j]) elif j == n-1: dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j]) else: dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]) return dp[0][0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>dynamic programming</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_Binary Search Tree Iterator]]></title>
    <url>%2F2019%2F04%2F07%2FLeetcode-BinarySearchTreeIterator%2F</url>
    <content type="text"><![CDATA[Binary Search Tree IteratorImplement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST.（设计二叉搜索树的迭代器） Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called. Example: 1. 中序遍历 &amp; 栈这道题主要考察的是二叉树的中序遍历的非递归形式，用中序遍历即可从小到大取出所有节点，但是需要额外定义一个栈来存储从根节点到左子树所有的左孩子结点。在不断迭代的过程中，不断地pop栈顶并实时将右结点push进去。具体实现过程如下： 1234567891011121314151617181920212223242526272829303132333435# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self.push_left(root) def next(self) -&gt; int: """ @return the next smallest number """ node = self.stack.pop() self.push_left(node.right) return node.val def hasNext(self) -&gt; bool: """ @return whether we have a next smallest number """ return bool(self.stack) def push_left(self, root): while root: self.stack.append(root) root = root.left# Your BSTIterator object will be instantiated and called as such:# obj = BSTIterator(root)# param_1 = obj.next()# param_2 = obj.hasNext()]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>design</tag>
        <tag>tree</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_Factorial Trailing Zeroes]]></title>
    <url>%2F2019%2F04%2F07%2FLeetcode-FactorialTrailingZeroes%2F</url>
    <content type="text"><![CDATA[Excel Sheet Column TitleGiven an integer n, return the number of trailing zeroes in n!.（求 n! 的末尾0的个数） Example: 1. 计算从1-n中含2，5的因子个数。题目中要求在时间复杂度为 O(log(n)) 的情况下完成。计算2和5的个数，实际上只需要计算5的个数，因为从1-n中因子2的个数一定大于5的个数。具体实现过程（循环 &amp; 递归）如下： 123456789class Solution: def trailingZeroes(self, n: int) -&gt; int: count_5 = 0 while n: count_5 += n // 5 n //= 5 return count_5 # return 0 if n == 0 else n // 5 + self.trailingZeroes(n // 5)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_Excel Sheet Column Number]]></title>
    <url>%2F2019%2F04%2F07%2FLeetcode-ExcelSheetColumnNumber%2F</url>
    <content type="text"><![CDATA[Excel Sheet Column NumberGiven a column title as appear in an Excel sheet, return its corresponding column number.（将EXCEL表格中的列名称转换成数值） Example: 1. 进制转换这道题可以看做是一道进制转换的题目，将26进制转换成十进制。具体实现方法如下： 123456789class Solution: def titleToNumber(self, s: str) -&gt; int: num = 0 for char in s: num = num * 26 num += ord(char) - ord('A') + 1 return num]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_Majority Element]]></title>
    <url>%2F2019%2F04%2F07%2FLeetcode-MajorityElement%2F</url>
    <content type="text"><![CDATA[Majority ElementGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array.(众数（次数大于n/2）) Example: 1. 哈希表构建一个哈希表来保存数组，统计每个元素的个数。也就是实现函数collections.Counter(nums)的功能。具体实现过程如下： 1234567891011121314from collections import defaultdict, Counterclass Solution: def majorityElement(self, nums: List[int]) -&gt; int: num_map = defaultdict(int) max_num, max_count = None, 0 for num in nums: num_map[num] += 1 if num_map[num] &gt; max_count: max_num, max_count = num, num_map[num] return max_num # counts = Counter(nums) # return max(counts.keys(), key=counts.get) 2. 排序由于此处的众数的定义为出现频次超过 n/2 的元素，因此先将数组进行排序，然后第 n/2 个元素一点就是“众数”。具体实现过程如下: 1234class Solution: def majorityElement(self, nums: List[int]) -&gt; int: nums.sort() return nums[len(nums) // 2]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>divide and conquer</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
        <tag>hash map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Joint_Intent_Classification_with_Slot_Filling]]></title>
    <url>%2F2019%2F04%2F04%2FJoint-Intent-Classification-with-Slot-Filling%2F</url>
    <content type="text"><![CDATA[意图识别 (Intent Classification) 和 槽位填充 (Slot Filling) 是自然语言理解 (Natural Language Understanding, NLU) 领域常见的两个子任务。意图识别可以看作一个分类任务，槽位填充则是一个序列标注问题，之前的模型往往是基于这两个任务构建两个模型来分别处理。最近提出了很多意图分类和槽位填充的联合学习模型，结合两个任务之间的依赖关系，提高了模型的效果。 1. Attention-Based Recurrent Neural Network Models for Joint Intent Detection and Slot Filling这篇论文可以看做是联合训练模型的 Baseline，很多新提出的模型的结果都会与之对比。模型的主要结构是基于 Attention 的 Encoder-Decoder 结构，其中 Encoder 是双向RNN，Decoder 是单向RNN ，具体模型结构图如下： 输入经过 Embedding 层之后经过 Encoder，其中序列最后一个的 hidden state 用来进行意图识别，同时作为 Decoder 的输入，Decoder 的每一个隐层结合 Attention 信息一起进行槽位填充。其中 Attention 的计算如下： 2. A Deep Learning Based Multi-task Ensemble Model for Intent Detection and Slot Filling in Spoken Language Understanding这篇论文对于输入的处理同样是双向 RNN。对于意图识别和槽位填充两个任务构建了两个分离的 MLP 分别训练，但是反向传播的过程中两者的结果都会影响 RNN 的参数。模型细节如下： 将 Word2Vec 和 GloVe 合在一起作为词语的 Embedding 输入RNN； 模型使用两个RNN，Bi-LSTM 和 Bi-GRU 分别处理输入，然后将结果合在一起(Ensemble)作为 MLP 的输入； 引入 词性信息POS 和 RNN 的结果拼接在一起作为 MLP 的输入。 3. Unsupervised Transfer Learning for Spoken Language Understanding in Intelligent Agents这是一篇AAAI 2019的论文，主要是使用了语言模型 ELMo 进行在大量没有标签的数据上进行预训练，然后 Transfer Learning 之后得到了比较好的效果。论文通过实验说明了在进行预训练之后使用 1k 条有标签数据 Fine-tuning 之后的结果与使用 10k-15k 条有标签数据从头开始的结果相当。模型细节如下： 由于对话场景中的语料一般是比较简短的，没有必要使用原始的模型结构，论文中的 ELMoL 是简化了 ELMo 后的结构，只用了一层的 Bi-LSTM。在语言模型训练好之后，移除前面的 CNN 层只保留最后的这层 Bi-LSTM 和 与意图识别和槽位填充相关的模型结构一起进行训练。同样地，对于意图识别和槽位填充也是两个分离的 Bi-LSTM，并在最后接上了一个 CRF 用于槽位填充。 在模型训练过程中使用的trick： Gradual Unfreezing：先开始仅更新顶层的参数而不改变较低层（靠近语言模型）的参数。 Triangular Learning Rate：三角学习率是指学习率先升后降，先开始比较小的学习率可以防止参数向错误方向进行更新。 Discriminative Fine Tuning：不同的层使用不同的学习率进行更新（较低层学习率较小）。 4. A Bi-model based RNN Semantic Frame Parsing Model for Intent Detection and Slot Filling这是一篇NAACL 2018的论文。之前的文章基本都是使用同一个 Bi-RNN 来对输入进行处理，这篇文章最大的不同是使用了两个 Bi-RNN 都对输入进行处理，但是这两个 Bi-RNN 不是分离的而是通过共享 Hidden State 相互关联的，模型细节如下： 图中有两个模型，不同点在于意图识别和槽位填充都分别增加了一个 LSTM 来进行解码，其他地方相同。可以看到： 用于意图识别的 Bi-RNN 的 Hidden State \(h^1\) 会输入到用于槽位填充的 Bi-RNN 跟 \(h^2\) 一起作为 RNN 单元的整个的 Hidden State 进行迭代； 同样地，用于槽位填充的 Bi-RNN 的 Hidden State \(h^2\) 也会输入到用于意图识别的 Bi-RNN 跟 \(h^1\) 一起作为 RNN 单元的整个的 Hidden State 进行迭代。 所以模型训练是异步进行的，也就是首先进行意图识别的训练得到一组 \(h^1\)，然后以同样的输入和这组 \(h^1\) 得到 \(h^2\)。 5. BERT for Joint Intent Classification and Slot FillingBERT 既可以用于分类问题，也可以用于序列标注问题，这篇文章是 BERT 在意图识别和槽位填充上的一个应用。文章模型中的意图识别部分继续沿用了 BERT 的 [CLS] 部分进行分类，槽位填充除了直接用输出进行序列标注之外还在上面接了一层 CRF（通过实验结果发现 CRF 的影响并不大）。 其中需要注意的是 BERT 使用了 WordPiece 对词语进行处理（可能一个词会被拆成多个sub-token，如 “redbreast” -&gt; “##red”, “##bre”, “##ast”），文章使用这些 sub-token 中的第一个（这里是 “##red” ）对应的模型的输出进行预测。模型细节如下： 6. 不同模型在 ATIS 数据上的结果 Model Intent Accuracy Slot F1 Attention BiRNN 98.21 95.98 BiRNN(Ensemble) &amp; MLP &amp; POS 98.43 98.07 ELMo &amp; Bi-LSTM &amp; CRF 97.42 95.62 Bi-model with a decoder 98.99 96.89 BERT 98.60 97.00]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>intent</tag>
        <tag>slot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm_KMP]]></title>
    <url>%2F2019%2F04%2F03%2Falgorithm-KMP%2F</url>
    <content type="text"><![CDATA[KMP（Knuth-Morris-Pratt 字符串子串位置） 在字符串 S 内查找子串 T 出现的位置，如果我们不考虑使用 KMP 算法，使用简单的轮循，具体实现过程如下： 1. 暴力轮循123456789101112131415161718s = 'bbc abcbab abcdabcdabde't = 'abcdabd'm, n = len(s), len(t)i, j = 0, 0while i &lt; m and j &lt; n: if s[i] == t[j]: i += 1 j += 1 else: i = i - j + 1 j = 0if j == n: return i - jelse: return -1 2. KMPKMP 算法的主要 trick 就是在于：若当前的 S 中的字符串序列与 T 不匹配，则它会记录下一个匹配可能从哪里开始（因为我们已经遍历了前面的字符），从而避免重新检查先前匹配的字符。时间复杂度为 O(m + n)。 Example: 如 S = BBC ABCDAB ABCDABCDABDE ，T= ABCDABD，则在外层循环扫描到 S中的 “A” 时，： 12345678&apos;BBC ABCDAB ABCDABCDABDE&apos;&apos; ABCDABD&apos; # 此时不匹配，我们可以直接从下一个 &quot;A&quot; 开始&apos;BBC ABCDAB ABCDABCDABDE&apos;&apos; ABCDABD&apos; # 此时不匹配，我们可以直接从下一个 &quot;A&quot; 开始&apos;BBC ABCDAB ABCDABCDABDE&apos;&apos; ABCDABD&apos; # 此时不匹配，我们可以直接从下一个 &quot;A&quot; 开始&apos;BBC ABCDAB ABCDABCDABDE&apos;&apos; ABCDABD&apos; # 此时不匹配，我们可以直接从下一个 &quot;A&quot; 开始 而这个算法的关键就在于我们如何记录不匹配时重新从哪里开始继续扫描，实质上是计算当前匹配了的字符串 T[:j]前缀后缀最长公共元素长度，上一个例子第一次中 T[:j] 为 ‘ABCDAB’：12&apos;ABCDAB&apos; 的前缀为 [A, AB, ABC, ABCD, ABCDA]&apos;ABCDAB&apos; 的后缀为 [B, AB, DAB, CDAB, BCDAB] 前缀后缀最长公共元素长度为2。我们可以求出 T 相应子串的前缀后缀最长公共元素长度为12A B C D A B D0 0 0 0 1 2 0 由于是否匹配在于第一个不匹配的元素，于是 Next 数组为12 A B C D A B D-1 0 0 0 0 1 2 最终 KMP 具体实现过程如下： 12345678910111213141516171819202122232425262728293031def get_next(t, n): Next = [0 for _ in range(n)] Next[0] = -1 j, k = 0, -1 while j &lt; n - 1: if k == -1 or t[j] == t[k]: j += 1 k += 1 Next[j] = k else: k = Next[k] return Nexts = 'bbc abcbab abcdabcdabde't = 'abcdabd'm, n = len(s), len(t)i, j = 0, 0Next = get_next(t, n)while i &lt; m and j &lt; n: if j==-1 or s[i] == t[j]: i += 1 j += 1 else: j = Next[j]if j == n: return i - jelse: return -1 3. KMP 变种问题描述：给定字符串，不断将首字母移动到末尾并记录所得的字符串，则不同的字符串有多少个。 解析：如果字符串中有循环的话，于是问题转化为求字符串中的循环节。假设字符串长度了n，利用 KMP 的 Next 数组求出的循环节长度为 Next[n] (注意：这里是n)，那么我们去掉循环部分得到的答案为 answer。 这里还需要注意的是当 n % answer == 0的时候答案是 answer，否则答案是 n 。比如 ‘abab’答案是2，’aabbaaa’ 这个样例答案是7。 具体实现过程如下： 12345678910111213141516171819202122def get_next(t, n): Next = [0 for _ in range(n + 1)] Next[0] = -1 j, k = 0, -1 while j &lt; n: if k == -1 or t[j] == t[k]: j += 1 k += 1 Next[j] = k else: k = Next[k] return Nextt = 'abab'n = len(t)Next = get_next(t, n)answer = n - Next[n]if n % answer == 0: print(answer)else: print(n)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Excel Sheet Column Title]]></title>
    <url>%2F2019%2F04%2F02%2Fleetcode-ExcelSheetColumnTitle%2F</url>
    <content type="text"><![CDATA[Excel Sheet Column TitleGiven a positive integer, return its corresponding column title as appear in an Excel sheet.（将数值转换成EXCEL表格中的列名称） Example: 1. 进制转换这道题可以看做是一道进制转换的题目，将十进制转换成26进制。其中，需要注意的是每次都使用 n-1 作为被除数是为了方便计算与 A 的 ASCII码的差值。具体实现方法如下： 12345678class Solution: def convertToTitle(self, n: int) -&gt; str: result = '' while n: n, remainder = divmod(n-1, 26) result = chr(ord('A') + remainder) + result return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Two Sum II]]></title>
    <url>%2F2019%2F04%2F02%2Fleetcode-TwoSumII%2F</url>
    <content type="text"><![CDATA[Two Sum IIGiven an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.（一个升序数组中某两个元素的和为给定值） Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: 1. 双指针首尾指针指向数组，通过与 target 判断大小来移动左、右指针，具体实现过程如下： 1234567891011class Solution: def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: left, right = 0, len(numbers)-1 while left &lt; right: if numbers[left] + numbers[right] == target: return [left+1, right+1] elif numbers[left] + numbers[right] &lt; target: left += 1 else: right -= 1 2. 二分查找首先定位左边的元素，然后通过二分查找查找右边的元素，具体实现过程如下： 123456789101112131415class Solution: def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: n = len(numbers) for i in range(n): new_target = target - numbers[i] left, right = i+1, n-1 while left &lt;= right: middle = (left + right) // 2 if numbers[middle] == new_target: return [i+1, middle+1] elif numbers[middle] &lt; new_target: left = middle + 1 else: right = middle - 1 3. 哈希表 （与Two Sum方法一致）]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Fraction to Recurring Decimal]]></title>
    <url>%2F2019%2F04%2F02%2Fleetcode-FractiontoRecurringDecimal%2F</url>
    <content type="text"><![CDATA[Fraction to Recurring DecimalGiven two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.（分数-&gt;小数） Example: 1. 哈希表本题意在将分数转换为小数点的形式表示，主要考察的是无限循环小数。在除法与商和余数的过程中，首先需要考虑符号的问题。其次，我们需要把每次的余数保存在 remainder_map 中，当下次出现余数已经出现了则说明出现了循环。具体实现方法如下： 12345678910111213141516171819202122232425class Solution: def fractionToDecimal(self, numerator: int, denominator: int) -&gt; str: if numerator * denominator &lt; 0: sign = '-' else: sign = '' result = sign integer, remainder = divmod(abs(numerator), abs(denominator)) result += str(integer) if remainder: result += '.' remainder_map = &#123;&#125; while remainder: if remainder not in remainder_map: remainder_map[remainder] = len(result) integer, remainder = divmod(remainder * 10, abs(denominator)) result += str(integer) else: index = remainder_map[remainder] result = result[:index] + '(' + result[index:] + ')' break return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>hash table</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Compare Version Numbers]]></title>
    <url>%2F2019%2F03%2F25%2Fleetcode-CompareVersionNumbers%2F</url>
    <content type="text"><![CDATA[Compare Version NumbersCompare two version numbers version1 and version2. If version1 &gt; version2 return 1; if version1 &lt; version2 return -1; otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character. The . character does not represent a decimal point and is used to separate number sequences. For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision. You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0.（比较’.’分开的数值大小） Example: 1. 字符串处理123456789101112131415161718192021222324252627282930313233class Solution(object): def compareVersion(self, version1, version2): """ :type version1: str :type version2: str :rtype: int """ data1 = version1.split('.') data2 = version2.split('.') m, n = len(data1), len(data2) for i in range(min(m, n)): if int(data1[i]) &gt; int(data2[i]): return 1 elif int(data1[i]) &lt; int(data2[i]): return -1 if m == n: return 0 if m &gt; n: num = int(''.join(data1[n:])) if num: return 1 else: return 0 if m &lt; n: num = int(''.join(data2[m:])) if num: return -1 else: return 0]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Maximum Gap]]></title>
    <url>%2F2019%2F03%2F25%2Fleetcode-MaximumGap%2F</url>
    <content type="text"><![CDATA[Maximum GapGiven an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements.（乱序数组的排序后相邻元素差最大值） Example: 1. 基数排序这道题的本质是一个排序问题，要求在时间复杂度和空间复杂度都是 O(n) 的前提下完成任务。基数排序的时间复杂度为 O(d*(n+k))≈O(n)，空间复杂度是 O(n+k)≈O(n)，其中 k 为基数，d为在k进制里面的最大位数。具体实现过程如下： 12345678910111213141516171819202122232425class Solution(object): def maximumGap(self, nums): """ :type nums: List[int] :rtype: int """ if not nums or len(nums) == 1: return 0 max_num = max(nums) bucket = [[] for i in range(10)] exp = 1 while max_num // exp &gt; 0: for num in nums: bucket[(num//exp) % 10].append(num) nums = [] for each in bucket: nums.extend(each) bucket = [[] for i in range(10)] exp *= 10 max_gap = 0 for i in range(1, len(nums)): max_gap = max(max_gap, nums[i]-nums[i-1]) return max_gap]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Find Peak Element]]></title>
    <url>%2F2019%2F03%2F23%2Fleetcode-FindPeakElement%2F</url>
    <content type="text"><![CDATA[Find Peak ElementA peak element is an element that is greater than its neighbors. sGiven an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞.（找到数组中的“波峰”值的index，一个即可。要求时间复杂度为O(logn)） Example: 1. 二分查找由于题中要求在时间复杂度为O(logn)的情况下实现，因此使用二分查找。 当 middle 正好是峰值时，直接返回。 当 nums[middle] &lt; nums[middle+1] 时，右边一定会存在峰值，因为 nums[n] = -∞，因此 left = middle。 其他情况，则左边会存在峰值，因此 right = middle。具体实现过程如下： 123456789101112131415161718192021class Solution(object): def findPeakElement(self, nums): """ :type nums: List[int] :rtype: int """ if not nums: return None left, right = 0, len(nums)-1 while left &lt; right - 1: middle = (left + right) // 2 if nums[middle] &gt; nums[middle-1] and nums[middle] &gt; nums[middle+1]: return middle if nums[middle] &lt; nums[middle+1]: left = middle else: right = middle return left if nums[left] &gt;= nums[right] else right]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>binary seach</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Intersection of Two Linked Lists]]></title>
    <url>%2F2019%2F03%2F23%2Fleetcode-IntersectionofTwoLinkedLists%2F</url>
    <content type="text"><![CDATA[Intersection of Two Linked ListsWrite a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists:（两个链表相交的结点） Example: 1. 暴力轮循使用这种方式的时间复杂度为 O(mn)，空间复杂度为 O(1)。 2. 哈希表使用这种方式的时间复杂度为 O(m+n)，空间复杂度为 O(m+n)。 3. 两个指针根据图中的示例，我们可以发现，两个链表若有交叉点，则主要长度不同的部分在交叉点之前。因此我们使用两个指针分别遍历两个链表，当某一个指针遍历到链尾时，从另一个链表开始。如此一来，在两个指针都遇到链尾并从头开始时，这一次的遍历一定会在相交点相遇。若不存在交叉点，则此时两个链表都在链尾为None。使用这种方式的时间复杂度为 O(m+n)，空间复杂度为 O(1)。具体实现过程如下： 12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None pA, pB = headA, headB while pA != pB: if pA: pA = pA.next else: pA = headB if pB: pB = pB.next else: pB = headA return pA]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>two pointers</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Min Stack]]></title>
    <url>%2F2019%2F03%2F17%2Fleetcode-MinStack%2F</url>
    <content type="text"><![CDATA[Min StackDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. （设计一个堆栈类，并可以O(1)定位到最小值） Example: 1. 牺牲空间复杂度来实现时间复杂度为了能够快速在动态出栈，入栈的过程中得到当前堆栈的最小值，我们需要维护一个与当前栈相同大小的“最小栈”，并在入栈的时候更新一致，具体实现过程如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class MinStack: def __init__(self): """ initialize your data structure here. """ self.stack = [] self.min_ele = [] def push(self, x: int) -&gt; None: if not self.stack: self.stack.append(x) self.min_ele.append(x) else: min_ele = min(self.min_ele[-1], x) self.stack.append(x) self.min_ele.append(min_ele) def pop(self) -&gt; None: self.stack.pop() self.min_ele.pop() def top(self) -&gt; int: if not self.stack: return None else: return self.stack[-1] def getMin(self) -&gt; int: if not self.stack: return None else: return self.min_ele[-1]# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin()]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>design</tag>
        <tag>easy</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Find Minimum in Rotated Sorted Array II]]></title>
    <url>%2F2019%2F03%2F17%2Fleetcode-FindMinimuminRotatedSortedArrayII%2F</url>
    <content type="text"><![CDATA[Find Minimum in Rotated Sorted Array IISuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates.（确定一个升序序列经过某个位置翻转后的数组的最小值(有重复元素)） Note: Would allow duplicates affect the run-time complexity? How and why? Example: 1. 二分查找与上一个不含重复元素的方法一致，只是在遇到相同的元素时，需要提前移动 left 和 right 指针。两者的时间复杂度都是 O(log(n))，但是在最坏的情况下，数组中全部是相同的元素，时间复杂度为O(n)。具体实现方法如下： 12345678910111213141516171819class Solution: def findMin(self, nums: List[int]) -&gt; int: n = len(nums) if n == 1: return nums[0] left, right = 0, n-1 while left &lt; right: while left &lt; right and nums[left+1] == nums[left]: left += 1 while left &lt; right and nums[right-1] == nums[right]: right -= 1 middle = (left + right) // 2 if nums[middle] &gt; nums[right]: left = middle + 1 else: right = middle return nums[left] 2. 二分查找另一种解决方案如下： 12345678910111213141516class Solution: def findMin(self, nums: List[int]) -&gt; int: n = len(nums) if n == 1: return nums[0] left, right = 0, n-1 while left &lt; right: middle = (left + right) // 2 if nums[middle] &gt; nums[right]: left = middle + 1 elif nums[middle] &lt; nums[left]: right = middle else: right -= 1 return nums[left]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Find Minimum in Rotated Sorted Array]]></title>
    <url>%2F2019%2F03%2F17%2Fleetcode-FindMinimuminRotatedSortedArray%2F</url>
    <content type="text"><![CDATA[Find Minimum in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array.（确定一个升序序列经过某个位置翻转后的数组的最小值） Example: 1. 二分查找二分查找： 在 nums[middle] &gt; nums[right]，如[3, 4, 5, 1, 2]，说明最小值必然在右边，因此left = middle + 1； 在 nums[middle] &lt;= nums[right]，如[5, 1, 2, 3, 4]，说明最小的必然在左边，因此right = middle；具体实现过程如下： 1234567891011121314class Solution: def findMin(self, nums: List[int]) -&gt; int: n = len(nums) if n == 1: return nums[0] left, right = 0, n-1 while left &lt; right: middle = (left + right) // 2 if nums[middle] &gt; nums[right]: left = middle + 1 else: right = middle return nums[left]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Maximum Product Subarray]]></title>
    <url>%2F2019%2F03%2F17%2Fleetcode-MaximumProductSubarray%2F</url>
    <content type="text"><![CDATA[Maximum Product SubarrayGiven an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.（最大子串乘积） Example: 1. 动态规划根据题意，需要找到数组中的某一个连续子数组，使得改部分的乘积最大，很明显的动规题目。具体实现过程如下： Note: 其中需要特别注意的是数组中存在负数，因此需要在遍历过程中考虑乘积最小的部分，这样通过符号的翻转反而可以得到最大值。 123456789101112131415161718192021class Solution: def maxProduct(self, nums: List[int]) -&gt; int: if not nums: return 0 n = len(nums) # 实际上可以不用维护一个数组，简单的变量即可。 dp_max = [0 for _ in range(n)] dp_min = [0 for _ in range(n)] dp_max[0] = nums[0] dp_min[0] = nums[0] for i in range(1, n): if nums[i] &gt;= 0: dp_max[i] = max(dp_max[i-1] * nums[i], nums[i]) dp_min[i] = min(dp_min[i-1] * nums[i], nums[i]) else: dp_max[i] = max(dp_min[i-1] * nums[i], nums[i]) dp_min[i] = min(dp_max[i-1] * nums[i], nums[i]) return max(dp_max) 降低空间复杂度的情况如下：12345678910111213class Solution: def maxProduct(self, nums: List[int]) -&gt; int: if not nums: return 0 dp_max, dp_min, result = nums[0], nums[0], nums[0] for i in range(1, len(nums)): temp1, temp2 = dp_min * nums[i], dp_max * nums[i] dp_max = max(temp1, temp2, nums[i]) dp_min = min(temp1, temp2, nums[i]) result = max(dp_max, result) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Reverse Words in a String]]></title>
    <url>%2F2019%2F03%2F17%2Fleetcode-ReverseWordsinaString%2F</url>
    <content type="text"><![CDATA[Reverse Words in a StringGiven an input string, reverse the string word by word.（翻转字符串中的词语） Note: A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string. Example: 1. 字符串函数使用 split join [::-1] 等常用的字符串换处理函数，具体实现过程如下： 123class Solution: def reverseWords(self, s: str) -&gt; str: return " ".join(word for word in s.split(' ')[::-1] if word)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Evaluate Reverse Polish Notation]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode-EvaluateReversePolishNotation%2F</url>
    <content type="text"><![CDATA[Evaluate Reverse Polish NotationEvaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression.（计算逆波兰表达式） Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation. Example: 1. 栈使用堆栈来计算逆波兰表达式。其中需要注意的是，题目中要求除法运算没有整除时要向 0 靠近，因此在两个异号的数相除时，应该 + 1 处理，或者转换为正数除法再加负号。具体实现过程如下： 1234567891011121314151617181920212223242526272829class Solution(object): def evalRPN(self, tokens): """ :type tokens: List[str] :rtype: int """ stack = [] for i in range(len(tokens)): if tokens[i] not in ['+', '-', '*', '/']: stack.append(int(tokens[i])) else: right = stack.pop() left = stack.pop() if tokens[i] == '+': stack.append(left + right) elif tokens[i] == '-': stack.append(left - right) elif tokens[i] == '*': stack.append(left * right) else: # 6 / -132 if left * right &lt; 0 and left % right != 0: stack.append(left / right + 1) # stack.append(-(abs(left) / abs(right))) else: stack.append(left / right) return stack[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Max Points on a Line]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode-MaxPointsonaLine%2F</url>
    <content type="text"><![CDATA[Max Points on a LineGiven n points on a 2D plane, find the maximum number of points that lie on the same straight line.（坐标系中共线最多的点数） Example: 1. 哈希表 + 穷举对每个点都计算一下该点和其他点连线的斜率，这样对于这个点来说，相同斜率的直线有多少条，就意味着有多少个点在同一条直线上。用哈希表，以斜率为key，记录有多少重复直线。但是通过斜率来判断共线需要用到除法，而用double表示的双精度小数在有的系统里不一定准确，为了更加精确无误的计算共线，我们应当避免除法，而使用约分之后的分数表示（记录分子分母）。具体实现过程如下： 1234567891011121314151617181920212223242526272829303132333435363738# Definition for a point.# class Point(object):# def __init__(self, a=0, b=0):# self.x = a# self.y = bfrom collections import defaultdictclass Solution(object): def maxPoints(self, points): """ :type points: List[Point] :rtype: int """ # 最大公约数 def gcd(a, b): if b == 0: return a else: return gcd(b, a % b) result = 0 for i in range(len(points)): k_map = defaultdict(int) duplicate_point = 1 for j in range(i+1, len(points)): if points[i].x == points[j].x and points[i].y == points[j].y: duplicate_point += 1 continue dx = points[j].x - points[i].x dy = points[j].y - points[i].y d = gcd(dx, dy) k_map[(dx/d, dy/d)] += 1 result = max(result, duplicate_point) for k in k_map: result = max(result, k_map[k] + duplicate_point) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>hash table</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Sort List]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode-SortList%2F</url>
    <content type="text"><![CDATA[Sort ListSort a linked list in O(n log n) time using constant space complexity.（实现实现复杂度为O(nlog(n))的链表排序） Example: 1. 归并排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def merge(self, left, right): new_head = ListNode(0) cur, left_i, right_i = new_head, left, right while left_i and right_i: if left_i.val &lt; right_i.val: cur.next = left_i left_i = left_i.next else: cur.next = right_i right_i = right_i.next cur = cur.next if left_i: cur.next = left_i else: cur.next = right_i return new_head.next def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head # 定位到链表的中部 slow, fast = head, head.next while fast and fast.next: slow = slow.next fast = fast.next.next middle = slow.next slow.next = None left = self.sortList(head) right = self.sortList(middle) return self.merge(left, right)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>linked list</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Insert in Sort List]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode-InsertionSortList%2F</url>
    <content type="text"><![CDATA[Insert in Sort ListSort a linked list using insertion sort.（基于链表的插入排序） Example: 1. 头指针维护一个含头指针的链表 j 来存储排序之后的结果，在遍历链表 i 的过程中，不断地扫描定位到链表 j 的位置，然后插入。具体实现过程如下： 1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head new_head = ListNode(-1) cur_i = head while cur_i: temp = cur_i.next cur_j = new_head while cur_j.next and cur_j.next.val &lt;= cur_i.val: cur_j = cur_j.next cur_i.next = cur_j.next cur_j.next = cur_i cur_i = temp return new_head.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>linked list</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_LRU Cache]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode-LRUCache%2F</url>
    <content type="text"><![CDATA[LRU CacheDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. （设计LRU算法的数据结构） Follow up: Could you do both operations in O(1) time complexity? Example: 1. 哈希表 + 双向链表这里使用哈希表和双向链表来构造 LRU 算法的数据结构，哈希表根据 key 可以直接索引到链表中相应的节点，可以实现时间复杂度是 O(1)。具体实现方法如下： Note: 在进行 get/put 操作之后，需要重新将该节点移到队首。 双向链表方便进行队首插入新节点，队尾删除纠结点的操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Node: def __init__(self, k, v, prev, next): self.key = k self.val = v self.prev = prev self.next = nextclass LRUCache(object): def __init__(self, capacity): """ :type capacity: int """ self.capacity = capacity self.cached = &#123;&#125; self.head = Node(0, 0, None, None) self.tail = Node(0, 0, None, None) self.head.next = self.tail self.tail.prev = self.head def add(self, node): node.next = self.head.next self.head.next.prev = node self.head.next = node node.prev = self.head self.cached[node.key] = node def remove(self, node): node.prev.next = node.next node.next.prev = node.prev del self.cached[node.key] del node def get(self, key): """ :type key: int :rtype: int """ if key in self.cached: value = self.cached[key].val self.remove(self.cached[key]) self.add(Node(key, value, None, None)) return value else: return -1 def put(self, key, value): """ :type key: int :type value: int :rtype: None """ if key in self.cached: self.remove(self.cached[key]) self.add(Node(key, value, None, None)) if len(self.cached) &gt; self.capacity: del self.cached[self.tail.prev.key] self.tail = self.tail.prev del self.tail.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>design</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Binary Tree Postorder Traversal]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode-BinaryTreePostorderTraversal%2F</url>
    <content type="text"><![CDATA[Binary Tree Postorder TraversalGiven a binary tree, return the postorder traversal of its nodes’ values.（后序遍历二叉树） Follow up: Recursive solution is trivial, could you do it iteratively? Example: 1. 递归具体实现方法如下： 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def helper(self, root, res): if not root: return res self.helper(root.left, res) self.helper(root.right, res) res.append(root.val) def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] result = [] self.helper(root, result) return result 2. 迭代 &amp; 栈由于先序遍历的顺序是根-左-右，后序遍历的顺序是左-右-根，因此可以修改先序遍历的遍历顺序为根-右-左，然后将最终结果倒序即可。具体实现方法如下： 123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] result, stack = [], [] p = root while stack or p: if p: result.append(p.val) stack.append(p.left) p = p.right else: p = stack.pop() return result[::-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>tree</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Binary Tree Preorder Traversal]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode-BinaryTreePreorderTraversal%2F</url>
    <content type="text"><![CDATA[Binary Tree Preorder TraversalGiven a binary tree, return the preorder traversal of its nodes’ values.（先序遍历二叉树） Follow up: Recursive solution is trivial, could you do it iteratively? Example: 1. 递归具体实现方法如下： 123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def helper(self, root, res): if not root: return res res.append(root.val) self.helper(root.left, res) self.helper(root.right, res) def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] result = [] self.helper(root, result) return result 2. 迭代 &amp; 栈先将访问根节点，然后将右子树节点加入到栈中，然后访问左子树。具体实现方法如下： 123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] result, stack = [], [] p = root while stack or p: if p: result.append(p.val) stack.append(p.right) p = p.left else: p = stack.pop() return result 123456789101112131415class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] stack, result = [root], [] while stack: p = stack.pop() result.append(p.val) if p.right: stack.append(p.right) if p.left: stack.append(p.left) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Reorder List]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode-ReorderList%2F</url>
    <content type="text"><![CDATA[Reorder ListGiven a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list’s nodes, only nodes itself may be changed.（链表重新排序） Example: 1. 切分 &amp; 倒叙链表首先使用 slow 和 fast 两个指针来遍历链表，找到链表的中部；然后将链表后半部分倒序；最终将倒序后的后半部分的链表插入到前半部分中。时间复杂度为O(n)，时间复杂度为O(1)。具体实现方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reorderList(self, head): """ :type head: ListNode :rtype: None Do not return anything, modify head in-place instead. """ if not head or not head.next: return # 找到链表的中部 slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next middle = slow.next slow.next = None # 将链表后半部分倒序 new_head = ListNode(0) while middle: temp = middle.next middle.next = new_head.next new_head.next = middle middle = temp # 将倒序后的后半部分的链表插入到前半部分中 p, q = head, new_head.next while p and q: temp = q.next q.next = p.next p.next = q q = temp p = p.next.next return]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Linked List Cycle II]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode-LinkedListCycleII%2F</url>
    <content type="text"><![CDATA[Linked List Cycle IIGiven a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.（链表中环的起点） Note: Do not modify the linked list. Example: 1. 两个指针根据前一题的思路，首先找到 slow 和 fast 第一次相遇的位置，则 slow 走了（x+a），fast 走了 （x+a+b+a）。（其中a为环中起始点到相遇点的位置，ba为环中相遇点再到起始点的位置），从而有 2(x+a）=（x+a+b+a），即x = b。说明 fast 从当前继续出发， slow 从链表头再出发，两者相遇的位置就是环起始位置。具体实现过程如下： 1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return None slow, fast = head, head.next while slow != fast: if not fast or not fast.next: return None slow = slow.next fast = fast.next.next slow, fast = head, fast.next while slow != fast: slow = slow.next fast = fast.next return slow]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>two pointers</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Linked List Cycle]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode-LinkedListCycle%2F</url>
    <content type="text"><![CDATA[Linked List CycleGiven a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.（链表有环） Follow up: Can you solve it using O(1) (i.e. constant) memory? Example: 1. 哈希表使用哈希表存储已经遍历过的结点，时间复杂度为 O(n)，空间复杂度为 O(n)。具体实现过程如下： 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head: return False node_set = set() p = head while p: if p in node_set: return True else: node_set.add(p) p = p.next return False 2. 双指针使用两个指针 slow 和 fast，在遍历链表的过程中，slow 移动一步，fast 移动两步。若存在环，两者一定会在某处相遇（在两者都进入环之后，fast一定会追赶上slow）。时间复杂度为 O(n)，空间复杂度为 O(1)。具体实现过程如下： 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head: return False slow, fast = head, head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>two pointers</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Word Break II]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode-WordBreakII%2F</url>
    <content type="text"><![CDATA[Word Break IIGiven a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.（字符串有效分词） Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example: 1. 动态规划 + 回溯法下面这种解法只使用了回溯，最终会导致 Time Limit Exceeded。 12345678910111213141516171819202122# Time Limit Exceeded# s = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"# wordDict = ["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","aaaaaaaaaa"]class Solution: def backtracking(self, s, res, start): if s[start:] in self.wordDict: self.results.append(" ".join(res + [s[start:]])) for i in range(start+1, len(s)): if s[start:i] in self.wordDict: self.backtracking(s, res+[s[start:i]], i) def wordBreak(self, s: str, wordDict: List[str]) -&gt; List[str]: if not s: return [] self.results = [] self.wordDict = wordDict self.backtracking(s, [], 0) return self.results 因此需要结合动态规划首先进行判断再回溯，最终具体解法如下：123456789101112131415161718192021222324252627282930313233class Solution: def wordBreak_check(self, s): if s in self.wordDict: return True dp = [False for _ in range(len(s) +1)] dp[0] = [True] for i in range(1, len(s)+1): for j in range(i): if s[j:i] in self.wordDict and dp[j]: dp[i] = True return dp[-1] def backtracking(self, s, res, start): if s[start:] in self.wordDict: self.results.append(" ".join(res + [s[start:]])) for i in range(start+1, len(s)): if s[start:i] in self.wordDict: self.backtracking(s, res+[s[start:i]], i) def wordBreak(self, s: str, wordDict: List[str]) -&gt; List[str]: self.wordDict = wordDict if not s or not self.wordBreak_check(s): return [] self.results = [] self.backtracking(s, [], 0) return self.results 1. 哈希表 + 回溯法这里维护了一个哈希表保存之前对字符串已经处理过的映射关系，例如memo[‘sanddog’] = ‘sand dog’这样就避免了重复多次计算。不会Time Limit Exceeded，具体实现方法如下： 1234567891011121314151617181920212223class Solution: def helper(self, s: str, wordDict: [str], memo: dict) -&gt; [str]: if s in memo: return memo[s] res =[] if not s: return res for word in wordDict: if not s.startswith(word): continue if len(s) == len(word): res.append(word) else: rest = self.helper(s[len(word):], wordDict, memo) for tmp in rest: tmp = word + ' ' + tmp res.append(tmp) memo[s] = res return res def wordBreak(self, s: str, wordDict: [str]) -&gt;[str]: memo = &#123;&#125; return self.helper(s, wordDict, memo)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>dynamic programming</tag>
        <tag>back tracking</tag>
        <tag>hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Word Break]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode-WordBreak%2F</url>
    <content type="text"><![CDATA[Word BreakGiven a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.（字符串是否可以有效分词） Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example: 1. 动态规划具体实现方法如下： 1234567891011121314class Solution: def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool: if s in wordDict: return True dp = [False for _ in range(len(s) +1)] dp[0] = [True] for i in range(1, len(s)+1): for j in range(i): if s[j:i] in wordDict and dp[j]: dp[i] = True return dp[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Copy List with Random Pointer]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode-CopyListwithRandomPointer%2F</url>
    <content type="text"><![CDATA[Copy List with Random PointerA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.（深拷贝链表） Note: You must return the copy of the given head as a reference to the cloned list. Example: 1. 哈希表首先忽略 random 遍历链表，构建链表节点到拷贝后节点之间的映射，然后考虑 random 重新遍历链表，根据映射关系维护新链表的链接关系，具体实现方法如下： 123456789101112131415161718192021222324252627282930"""# Definition for a Node.class Node: def __init__(self, val, next, random): self.val = val self.next = next self.random = random"""class Solution: def copyRandomList(self, head: 'Node') -&gt; 'Node': if not head: return None node_map = &#123;&#125; p = head while p: new_node = Node(p.val, None, None) node_map[p] = new_node p = p.next p = head q = copy_head = Node(0, None, None) while p: q.next = node_map[p] if p.random: q.next.random = node_map[p.random] p = p.next q = q.next return copy_head.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>hash table</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Single Number II]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode-SingleNumberII%2F</url>
    <content type="text"><![CDATA[Single Number IIGiven a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.（只出现一次的数字(其余出现三次)） Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example: 1. 按位操作ones / twos / threes 表示将数组中所有整形数转为二进制后，每个位上1出现次数为1/2/3次的情况； 12345678910111213class Solution: def singleNumber(self, nums: List[int]) -&gt; int: ones, twos, threes = 0, 0, 0 for num in nums: twos |= ones &amp; num ones ^= num threes = twos &amp; ones # 当ones和twos中的某一位同时为1时表示二进制1出现3次，此时需要清零。 ones &amp;= ~threes twos &amp;= ~threes return ones 2. 使用Python库Counter123456789from collections import Counterclass Solution: def singleNumber(self, nums: List[int]) -&gt; int: nums_map = dict(Counter(nums)) for num in nums_map: if nums_map[num] == 1: return num]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Single Number]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode-SingleNumber%2F</url>
    <content type="text"><![CDATA[Single NumberGiven a non-empty array of integers, every element appears twice except for one. Find that single one.（只出现一次的数字(其余出现两次)） Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example: 1. 哈希表使用哈希表保存数组，时间复杂度为O(n)，空间复杂度为O(n)。具体实现过程如下： 12345678910111213class Solution: def singleNumber(self, nums: List[int]) -&gt; int: num_dict = &#123;&#125; for num in nums: if num not in num_dict: num_dict[num] = 1 else: num_dict[num] += 1 for key in num_dict: if num_dict[key] == 1: return key 2. 按位异或题中要求使用时间复杂度为O(n)，空间复杂度为O(1)。在遍历数组的过程中使用按位异或的方法，最终会保留下只存在一次的数字。具体实现过程如下： 123456class Solution: def singleNumber(self, nums: List[int]) -&gt; int: result = 0 for num in nums: result ^= num return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>hash table</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Candy]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode-Candy%2F</url>
    <content type="text"><![CDATA[CandyThere are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give?（分糖问题） Example: 1. 贪心算法 (两次遍历)根据题意要求按权重分糖，每个人至少有一个糖，有较高权重的必须比相邻的人有更多的糖。第一遍从左向右遍历，如果右边的权重大，等加一个糖果，这样保证了一个方向上高权重的糖果多。然后再从右向左遍历一遍，如果相邻两个左边的等级高，而左边的糖果又少的话，则左边糖果数为右边糖果数加一。时间复杂度为O(n)，空间复杂度为O(n)。具体实现过程如下： 1234567891011121314class Solution: def candy(self, ratings: List[int]) -&gt; int: n = len(ratings) nums = [1 for _ in range(n)] for i in range(1, n): if ratings[i] &gt; ratings[i-1]: nums[i] = nums[i-1] + 1 for i in range(n-2, -1, -1): if ratings[i] &gt; ratings[i+1]: nums[i] = max(nums[i+1]+1, nums[i]) return sum(nums)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Gas Station]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode-GasStation%2F</url>
    <content type="text"><![CDATA[Gas StationThere are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.（加油站问题） Note: If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer. Example: 1. 贪心算法这是一道很直接的贪心的题目，题中要求在一个环形的轨道中选择一个出发点，使得在路途中的经历耗油、加油可以成功的会到出发点。起点 start 将路径分为前后两段，前段总的余量为负，即油不够用，要想有解，那么后段油量应该为正，此时才可能有解，我们要做的就是找到这个分割点作为起点，然后再验证一下；反之，如果前段就为正了，那么显然可以直接选择前面的点为起点；如果整段加起来都是负的，那么无解。具体实现过程如下： 1234567891011121314class Solution: def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int: total, remain, start = 0, 0, 0 for i in range(len(gas)): remain += gas[i] - cost[i] total += gas[i] - cost[i] if remain &lt; 0: start = i + 1 remain = 0 if total &lt; 0: return -1 return start]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Clone Graph]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode-CloneGraph%2F</url>
    <content type="text"><![CDATA[Clone GraphGiven a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.（深度拷贝图） Note: The number of nodes will be between 1 and 100. The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph. Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too. You must return the copy of the given node as a reference to the cloned graph. Example: 1. DFS (递归)1234567891011121314151617181920212223242526272829"""# Definition for a Node.class Node: def __init__(self, val, neighbors): self.val = val self.neighbors = neighbors"""class Solution: def dfs(self, node): for _node in node.neighbors: if _node not in self.map_dict: copy_neighbor = Node(_node.val, []) self.map_dict[_node] = copy_neighbor self.map_dict[node].neighbors.append(copy_neighbor) self.dfs(_node) else: self.map_dict[node].neighbors.append(self.map_dict[_node]) return def cloneGraph(self, node: 'Node') -&gt; 'Node': if not node: return None self.map_dict = &#123;&#125; copy_node = Node(node.val, []) self.map_dict[node] = copy_node self.dfs(node) return copy_node 2. DFS (栈)1234567891011121314151617181920212223242526272829"""# Definition for a Node.class Node: def __init__(self, val, neighbors): self.val = val self.neighbors = neighbors"""class Solution: def cloneGraph(self, node: 'Node') -&gt; 'Node': if not node: return None map_dict = &#123;&#125; copy_node = Node(node.val, []) map_dict[node] = copy_node stack = [node] while stack: _node = stack.pop() for neighbor in _node.neighbors: if neighbor not in map_dict: copy_neignbor = Node(neighbor.val, []) map_dict[neighbor] = copy_neignbor map_dict[_node].neighbors.append(copy_neignbor) stack.append(neighbor) else: map_dict[_node].neighbors.append(map_dict[neighbor]) return copy_node 3. BFS (队列)1234567891011121314151617181920212223242526272829"""# Definition for a Node.class Node: def __init__(self, val, neighbors): self.val = val self.neighbors = neighbors"""class Solution: def cloneGraph(self, node: 'Node') -&gt; 'Node': if not node: return None map_dict = &#123;&#125; copy_node = Node(node.val, []) map_dict[node] = copy_node queue = [node] while queue: _node = queue.pop(0) for neighbor in _node.neighbors: if neighbor not in map_dict: copy_neignbor = Node(neighbor.val, []) map_dict[neighbor] = copy_neignbor map_dict[_node].neighbors.append(copy_neignbor) queue.append(neighbor) else: map_dict[_node].neighbors.append(map_dict[neighbor]) return copy_node]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Palindrome Partitioning II]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode-PalindromePartitioningII%2F</url>
    <content type="text"><![CDATA[Palindrome Partitioning IIGiven a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s.（最少切分字符串，每个子串都是回文序列） Example: 1. 动态规划首先维护一个二维矩阵来保存 s[i:j] 是否为回文序列。使用一维动规，初始化 dp 为字符串的索引（默认不存在任何回文序列的部分）；在双重循环遍历字符串的过程中判断 s[i:j+1] 是否为回文序列，若是： 在i==0时，表示字符串 s[:j+1]为回文序列，则dp[j] = 0 否则，取 dp[i-1] + 1 和 dp[j] 的 最小值，也就是在 i 处切分字符串。具体实现方法： 1234567891011121314151617181920class Solution: def minCut(self, s: str) -&gt; int: if not s or s[::-1] == s: return 0 n = len(s) palindrome = [[False]*(n) for _ in range(n)] dp = [i for i in range(n)] for j in range(n): for i in range(j+1): if s[i]==s[j] and (j-i&lt;2 or palindrome[i+1][j-1]): palindrome[i][j] = True if i==0: dp[j] = 0 elif dp[i-1] + 1 &lt; dp[j]: dp[j] = dp[i-1] + 1 return dp[n-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Palindrome Partitioning]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode-PalindromePartitioning%2F</url>
    <content type="text"><![CDATA[Palindrome PartitioningGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.（切分字符串，每个子串都是回文序列） Example: 1. 回溯法下面是一个标准的回溯法的模板： 12345678910111213141516171819class Solution: def checking(self, string): return string[::-1] == string def back_tracking(self, s, res, start): if start == len(s) and len(res) &gt; 0: self.results.append(res) for i in range(start, len(s)): if self.checking(s[start:i+1]): self.back_tracking(s, res+[s[start:i+1]], i+1) def partition(self, s: str) -&gt; List[List[str]]: if not s: return [] self.results = [] self.back_tracking(s, [], 0) return self.results]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Surrounded Regions]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode-SurroundedRegions%2F</url>
    <content type="text"><![CDATA[Surrounded RegionsGiven a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’. A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.（包围区域） Note: Surrounded regions shouldn’t be on the border, which means that any ‘O’ on the border of the board are not flipped to ‘X’. Any ‘O’ that is not on the border and it is not connected to an ‘O’ on the border will be flipped to ‘X’. Two cells are connected if they are adjacent cells connected horizontally or vertically. Example: 根据题中的意思，也就是矩阵中边界出向联通的 ‘O’ 不会被修改为 ‘X’，其他的会修改为 ‘X’，下面使用基于图的 DFS 、BFS、Union Find 三种方法实现。都是先将与边界 ‘O’ 联通的置位 ‘*‘, 其他的会修改为 ‘X’，然后再将 ‘*‘ 修改为 ‘O’。 1. DFS发现有问题先放入栈中，出栈时处理，具体实现过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def dfs(self, board, i, j): if board[i][j] != 'O': return stack = [(i, j)] while stack: node_i, node_j = stack.pop() board[node_i][node_j] = '*' if node_i-1 &gt;= 0 and board[node_i-1][node_j] == 'O': stack.append((node_i-1, node_j)) if node_i+1 &lt; self.m and board[node_i+1][node_j] == 'O': stack.append((node_i+1, node_j)) if node_j-1 &gt;= 0 and board[node_i][node_j-1] == 'O': stack.append((node_i, node_j-1)) if node_j+1 &lt; self.n and board[node_i][node_j+1] == 'O': stack.append((node_i, node_j+1)) return def solve(self, board: List[List[str]]) -&gt; None: """ Do not return anything, modify board in-place instead. """ if not board or not board[0]: return self.m, self.n = len(board), len(board[0]) for i in range(self.m): self.dfs(board, i, 0) self.dfs(board, i, self.n-1) for j in range(self.n): self.dfs(board, 0, j) self.dfs(board, self.m-1, j) for i in range(self.m): for j in range(self.n): if board[i][j] == '*': board[i][j] = 'O' elif board[i][j] == 'O': board[i][j] = 'X' return 2. BFS发现有问题立马处理，否则会Time Limit Exceeded，具体实现过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution: def bfs(self, board, i, j): if board[i][j] != 'O': return queue = [(i, j)] board[i][j] = '*' while queue: node_i, node_j = queue.pop(0) if node_i-1 &gt;= 0 and board[node_i-1][node_j] == 'O': queue.append((node_i-1, node_j)) board[node_i-1][node_j] = '*' if node_i+1 &lt; self.m and board[node_i+1][node_j] == 'O': queue.append((node_i+1, node_j)) board[node_i+1][node_j] = '*' if node_j-1 &gt;= 0 and board[node_i][node_j-1] == 'O': queue.append((node_i, node_j-1)) board[node_i][node_j-1] = '*' if node_j+1 &lt; self.n and board[node_i][node_j+1] == 'O': queue.append((node_i, node_j+1)) board[node_i][node_j+1] = '*' return def solve(self, board: List[List[str]]) -&gt; None: """ Do not return anything, modify board in-place instead. """ if not board or not board[0]: return self.m, self.n = len(board), len(board[0]) for i in range(self.m): self.bfs(board, i, 0) self.bfs(board, i, self.n-1) for j in range(self.n): self.bfs(board, 0, j) self.bfs(board, self.m-1, j) for i in range(self.m): for j in range(self.n): if board[i][j] == '*': board[i][j] = 'O' elif board[i][j] == 'O': board[i][j] = 'X' return]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Sum Root to Leaf Numbers]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode-SumRoottoLeafNumbers%2F</url>
    <content type="text"><![CDATA[Sum Root to Leaf NumbersGiven a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers.（树型数值之和） Note: A leaf is a node with no children. Example: 1. DFS常规的 DFS 算法，具体实现过程如下： 12345678910111213141516171819202122232425262728293031323334# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def dfs(self, root): if not root: return left = self.dfs(root.left) right = self.dfs(root.right) if not left and not right: return str(root.val) result = [] if left: for num in left: result.append(str(root.val)+str(num)) if right: for num in right: result.append(str(root.val)+str(num)) return result def sumNumbers(self, root: TreeNode) -&gt; int: if not root: return 0 nums = self.dfs(root) return sum(int(num) for num in nums)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Longest Consecutive Sequence]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode-LongestConsecutiveSequence%2F</url>
    <content type="text"><![CDATA[Longest Consecutive SequenceGiven an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity.（时间复杂度为O(n)，乱序数组中找到最长连续的数列） Example: 1. 哈希使用 set 对数组进行hash，这样可以实现遍历数组时迅速定位，具体实现过程如下： 12345678910111213class Solution: def longestConsecutive(self, nums: List[int]) -&gt; int: s = set(nums) res = 0 for i in range(len(nums)): if nums[i]-1 not in s: j = nums[i] while j in s: j += 1 res = max(res, j - nums[i]) return res 2. 并查集并查集是一种常用的解决联通性问题的一种数据结构。首先对数组中的每个数字建立 数-&gt;index 的映射，在映射过程中维护并查集将连续的数字的根节点合并，最终判断根节点最多的那一个也就是联通子图中的最大个数。具体实现方法如下： 123456789101112131415161718192021222324252627282930313233class Solution: def find(self, i): if self.parent[i] != -1: return self.find(self.parent[i]) return i def union(self, i, j): root_i = self.find(i) root_j = self.find(j) self.parent[root_i] = root_j def longestConsecutive(self, nums: List[int]) -&gt; int: n = len(nums) self.parent = [-1 for _ in range(n)] nums_map = &#123;&#125; for i in range(n): if nums[i] in nums_map: continue nums_map[nums[i]] = i if nums[i]-1 in nums_map: self.union(i, nums_map[nums[i]-1]) if nums[i]+1 in nums_map: self.union(i, nums_map[nums[i]+1]) max_length = 0 count = [0 for i in range(n)] for i in range(n): count[self.find(i)] += 1 max_length = max(count[self.find(i)], max_length) return max_length]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>array</tag>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Word Ladder II]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode-WordLadderII%2F</url>
    <content type="text"><![CDATA[Word Ladder IIGiven two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord.（词语阶梯） Note: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example: 1. BFS + DFS + BackTracking下面这个解法最终并没有成功AC，主要就是超时(Time Limit Exceeded)的问题。先根据 BFS 找到最短的转换次数，然后在 DFS 进行求解的过程中将解法超过最短的转换次数的剪枝。具体实现过程如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution: def minladderLength(self, beginWord): queue = [(beginWord, 1)] visited = [beginWord] while queue: word, step = queue.pop(0) if word == self.endWord: return step for i in range(len(word)): word_pattern = word[:i] + '*' + word[i+1:] if word_pattern in self.word_map: for _word in self.word_map[word_pattern]: if _word not in visited: queue.append((_word, step+1)) visited.append(_word) return 0 def back_tracking(self, res, visited): if len(res) &gt; self.min_step: return word = res[-1] if word == self.endWord: self.results.append(res) for i in range(len(word)): word_pattern = word[:i] + '*' + word[i+1:] if word_pattern in self.word_map: for _word in self.word_map[word_pattern]: if _word != word and _word not in visited: visited.append(_word) self.back_tracking(res + [_word], visited) visited.remove(_word) def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -&gt; List[List[str]]: if not wordList or endWord not in wordList: return [] self.word_map = &#123;&#125; for word in wordList: for i in range(len(word)): word_pattern = word[:i] + '*' + word[i+1:] if word_pattern not in self.word_map: self.word_map[word_pattern] = [word] else: self.word_map[word_pattern].append(word) self.endWord = endWord self.min_step = self.minladderLength(beginWord) self.results = [] self.back_tracking([beginWord], [beginWord]) return self.results 2. BFS + DFS + BackTracking下面这个方案是参照别人的解法，改进的地方就是在BFS的过程中，记录每个访问过的word距离beginWord的距离，显然 dis[beginword]=0, dis[endword]=minstep-1。然后逆向DFS(从终止点开始)，对于每个每个即将要拓展的点最短路径必然满足的条件是：dis[word] + pathsize = minstep。具体实现过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution: def minladderLength(self, beginWord): queue = [(beginWord, 1)] visited = [beginWord] while queue: word, step = queue.pop(0) if word == self.endWord: return step for i in range(len(word)): word_pattern = word[:i] + '*' + word[i+1:] if word_pattern in self.word_map: for _word in self.word_map[word_pattern]: if _word not in visited: self.dis[_word] = step # get the distance to the begin word queue.append((_word, step+1)) visited.append(_word) return 0 def back_tracking(self, res, visited): if len(res) &gt; self.min_step: return word = res[0] # confirm the second word in the path if len(res) == self.min_step-1 and self.dis[word] == 1: self.results.append([self.beginWord] + res) for i in range(len(word)): word_pattern = word[:i] + '*' + word[i+1:] if word_pattern in self.word_map: for _word in self.word_map[word_pattern]: if _word != word and _word not in visited: # 剪枝 if _word not in self.dis or self.dis[_word] + len(res) &gt; self.min_step: continue else: visited.append(_word) self.back_tracking([_word] + res, visited) visited.remove(_word) def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -&gt; List[List[str]]: if not wordList or endWord not in wordList: return [] self.word_map = &#123;&#125; for word in wordList: for i in range(len(word)): word_pattern = word[:i] + '*' + word[i+1:] if word_pattern not in self.word_map: self.word_map[word_pattern] = [word] else: self.word_map[word_pattern].append(word) self.endWord = endWord self.beginWord = beginWord self.dis = &#123;&#125; self.dis[beginWord] = 0 self.min_step = self.minladderLength(beginWord) self.results = [] self.back_tracking([endWord], [endWord]) return self.results 3. BackTracking另一种比较简单的做法，从 beginWord 出发，逐一修改 beginWord 中的字符，将第一次出现在 wordList 的词维护一个map保存，按同样的方式遍历这些词语直到找到 endWord。 然后从 endWord 出发逆向 DFS，具体实现过程如下： 1234567891011121314151617181920212223242526272829303132333435from collections import defaultdictfrom string import ascii_lowercaseclass Solution: def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -&gt; List[List[str]]: dictionary = set(wordList) result, cur, visited, found, trace = [], [beginWord], set([beginWord]), False, defaultdict(list) while cur and not found: for word in cur: visited.add(word) next = set() for word in cur: for i in range(len(word)): for c in ascii_lowercase: candidate = word[:i] + c + word[i + 1:] if candidate not in visited and candidate in dictionary: if candidate == endWord: found = True next.add(candidate) trace[candidate].append(word) cur = next if found: self.backtrack(result, trace, [], endWord) return result def backtrack(self, result, trace, path, word): if not trace[word]: result.append([word] + path) else: for prev in trace[word]: self.backtrack(result, trace, [word] + path, prev) Note: 这里dictionary = set(wordList)很重要，不然也会超时(Time Limit Exceeded)。set和list可以自由转换，在删除list中多个/海量重复元素时，可以先转换成set，然后再转回list并排序(set没有排序)，此种方法不仅方便且效率较高。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>array</tag>
        <tag>back tracking</tag>
        <tag>bfs</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Word Ladder]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode-WordLadder%2F</url>
    <content type="text"><![CDATA[Word LadderGiven two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord.（词语阶梯） Note: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example: 1. 宽度优先搜索根据题意实际上是找到从 beginWord 转换到 endWord 总共需要的步数。首先根据处理 wordList 将可以通过一次相互转换的 word 放入一个map中，根据bfs的过程遍历word所有可能的转换（经过转换的词语需要标记为visited）。具体实现过程如下： 12345678910111213141516171819202122232425262728class Solution: def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -&gt; int: if not wordList or endWord not in wordList: return 0 word_map = &#123;&#125; for word in wordList: for i in range(len(word)): word_pattern = word[:i] + '*' + word[i+1:] if word_pattern not in word_map: word_map[word_pattern] = [word] else: word_map[word_pattern].append(word) queue = [(beginWord, 1)] visited = [beginWord] while queue: word, step = queue.pop(0) if word == endWord: return step for i in range(len(word)): word_pattern = word[:i] + '*' + word[i+1:] if word_pattern in word_map: for _word in word_map[word_pattern]: if _word not in visited: queue.append((_word, step+1)) visited.append(_word) return 0 Note: 这里如果不事先处理 wordList 而是用 a-z 替换 word 中的字符回导致超时。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Valid Palindrome]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode-ValidPalindrome%2F</url>
    <content type="text"><![CDATA[Valid PalindromeGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.（回文字符串） Note: For the purpose of this problem, we define empty string as valid palindrome. Example: 1. 双指针两个指针分别指向字符串的首尾，查到符合要求的字符时就判断两者是否相同。具体实现过程如下： 123456789101112131415161718192021class Solution: def isPalindrome(self, s: str) -&gt; bool: if not s: return True n = len(s) i, j = 0, n-1 s = s.lower() while i&lt;j: # 需要注意保证i，j的有效性 while i&lt;n and not s[i].isalnum(): i+=1 while j&gt;=0 and not s[j].isalnum(): j-=1 if i&lt;=j and s[i] != s[j]: return False i+=1 j-=1 return True 2.翻转判断翻转后的字符串与原来是是否一致，空间复杂度是 O(n) 。具体实现过程如下： 12345class Solution: def isPalindrome(self, s: str) -&gt; bool: s = s.lower() s = ''.join([t for t in s if t.isalnum()]) return s == s[::-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Binary Tree Maximum Path Sum]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode-BinaryTreeMaximumPathSum%2F</url>
    <content type="text"><![CDATA[Binary Tree Maximum Path SumGiven a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.（二叉树最大路径和） Example: 1. 递归在二叉树中找一条路径，使得该路径的和最大。该路径可以从二叉树任何结点开始，也可以到任何结点结束。因此在递归求一条经过root的最大路径时，这条路径可能是： 左边某条路径 + root + 右边某条路径 root + 左边某条路径 root + 右边某条路径 root具体实现过程如下： 12345678910111213141516171819202122232425262728293031# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def helper(self, root): if not root: return 0 max_path = root.val left_child = self.helper(root.left) right_child = self.helper(root.right) if left_child &gt; 0: max_path += left_child if right_child &gt; 0: max_path += right_child self.global_max = max(self.global_max, max_path) # 返回根节点、左子树到该节点、右子树到该节点三条路径的最大值（为保证与当前根节点的祖宗节点的连通性） return max(root.val, root.val+left_child, root.val+right_child) def maxPathSum(self, root: TreeNode) -&gt; int: self.global_max = float('-inf') self.helper(root) return self.global_max]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Best Time to Buy and Sell Stock III]]></title>
    <url>%2F2019%2F03%2F12%2Fleetcode-BestTimetoBuyandSellStockIII%2F</url>
    <content type="text"><![CDATA[Best Time to Buy and Sell Stock IIISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions.（股票收益） Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example: 1. 动态规划题中的意思是指可以进行至多两次买入卖出的操作。可以以 i 划分整个时间，根据Best Time to Buy and Sell Stock中最大只能买卖一次的算法计算[0,i]的最大收益以及[i,n]的最大收益。具体实现过程如下： 123456789101112131415161718192021222324class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 n = len(prices) left = [0 for _ in range(n)] right = [0 for _ in range(n)] min_price, max_price = prices[0], prices[n-1] for i in range(1, n): left[i] = max(left[i-1], prices[i] - min_price) if prices[i] &lt; min_price: min_price = prices[i] right[n-1-i] = max(right[n-i], max_price - prices[n-1-i]) if prices[n-1-i] &gt; max_price: max_price = prices[n-1-i] final_profit = 0 for i in range(n): final_profit = max(final_profit, left[i] + right[i]) return final_profit]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Best Time to Buy and Sell Stock II]]></title>
    <url>%2F2019%2F03%2F12%2Fleetcode-BestTimetoBuyandSellStockII%2F</url>
    <content type="text"><![CDATA[Best Time to Buy and Sell Stock IISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).（股票收益） Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example: 1. 单重循环题中的意思是指可以进行多次买入卖出的操作，这个过程实际上也就是在每次股价要降低前卖出，在每次股价要上升时买入，因此只需要计算每次上升的过程中的的差价即可。具体实现过程如下： 1234567891011class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 max_profit = 0 for i in range(1, len(prices)): if prices[i] &gt; prices[i-1]: max_profit += prices[i] - prices[i-1] return max_profit]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Best Time to Buy and Sell Stock]]></title>
    <url>%2F2019%2F03%2F12%2Fleetcode-BestTimetoBuyandSellStock%2F</url>
    <content type="text"><![CDATA[Best Time to Buy and Sell StockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one.（股票收益） Example: 1. 双重循环类似于插入排序的方法，外层 i 从 [0,n-1） 循环，内层 j 从 [i+1, n） 循环，获取遍历过程中的最大值。 2. 单重循环 &amp; 动态规划只进行一次遍历，在遍历过程中发现价格小于买入的价格时，修改最低价表示买入；当收益大于最大收益时，修改最大收益值。（这里使用elif 是因为买入必须在卖掉之前。）具体实现过程如下： 1234567891011121314class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 max_profit, min_price = 0, float('inf') for i in range(len(prices)): if prices[i] &lt; min_price: min_price = prices[i] elif prices[i] - min_price &gt; max_profit: max_profit = prices[i] - min_price return max_profit]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>dynamic programming</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Triangle]]></title>
    <url>%2F2019%2F03%2F11%2Fleetcode-Triangle%2F</url>
    <content type="text"><![CDATA[TriangleGiven a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.(计算三角矩阵的最短路径) Example: 1. 动态规划从上到下寻找最短路径，可以从下到上进行回溯。在向上回溯的过程中，动态规划的递归表达式为 dp[j] = min(dp[j], dp[j+1]) + triangle[i][j] (因为是三角矩阵，所以从下到上的过程中只需要看 j 和 j+1 即可) 根据这个算法空间复杂度为 O(n)，具体实现过程如下： 12345678910111213class Solution: def minimumTotal(self, triangle: List[List[int]]) -&gt; int: if not triangle: return 0 n = len(triangle) dp = [0 for _ in range(n+1)] for i in range(n-1, -1, -1): for j in range(i+1): dp[j] = min(dp[j], dp[j+1]) + triangle[i][j] return dp[0]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Pascal's Triangle II]]></title>
    <url>%2F2019%2F03%2F11%2Fleetcode-PascalsTriangleII%2F</url>
    <content type="text"><![CDATA[Pascal’s Triangle IIGiven a non-negative index k where k ≤ 33, return the k_th index row of the Pascal’s triangle. Note that the row index starts from 0.(第k行杨辉三角) Example: 1. 逐层生成维护两个数组 result 和 result_before 表示当前层和前一层的结果，空间复杂度为 O(k). 具体实现过程如下： 123456789101112131415class Solution: def getRow(self, rowIndex: int) -&gt; List[int]: if rowIndex == 0: return [1] if rowIndex == 1: return [1, 1] result = [1, 1] for i in range(1, rowIndex): result_before = result result = [1, 1] for j in range(1, i+1): result.insert(j, result_before[j] + result_before[j-1]) return result 2. 直接生成根据杨辉三角的生成过程来维护一个数组，空间复杂度为 O(k). 具体实现过程如下： 12345678910class Solution: def getRow(self, rowIndex: int) -&gt; List[int]: result = [1 for i in range(rowIndex + 1)] for i in range(2, rowIndex + 1): aux = result[0] for j in range(1, i): result[j], aux = result[j]+aux, result[j] return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Pascal's Triangle]]></title>
    <url>%2F2019%2F03%2F11%2Fleetcode-PascalsTriangle%2F</url>
    <content type="text"><![CDATA[Pascal’s TriangleGiven a non-negative integer numRows, generate the first numRows of Pascal’s triangle.(杨辉三角) Example: 1. 逐层生成根据杨辉三角的规律，组成生成杨辉三角，具体实现过程如下： 1234567891011121314151617class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: if numRows == 0: return [] results = [] for i in range(numRows): if i == 0: results.append([1]) else: list = [1] for j in range(i-1): list.append(results[i-1][j] + results[i-1][j+1]) list.append(1) results.append(list) return results]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Populating Next Right Pointers in Each Node II]]></title>
    <url>%2F2019%2F03%2F06%2Fleetcode-PopulatingNextRightPointersinEachNodeII%2F</url>
    <content type="text"><![CDATA[Populating Next Right Pointers in Each Node IIGiven a binary tree, Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.（连接二叉树同一层的结点） Example: 1. 递归首先根据根节点的 next 指针找到这个子树的孩子节点的 next 需要连接的位置，然后将孩子节点通过 next 连接起来，再处理子树部分。具体实现过程如下： 123456789101112131415161718192021222324252627282930313233343536"""# Definition for a Node.class Node: def __init__(self, val, left, right, next): self.val = val self.left = left self.right = right self.next = next"""class Solution: def connect(self, root: 'Node') -&gt; 'Node': if not root: return root p = root.next while p: if p.left: p = p.left break if p.right: p = p.right break p = p.next if root.right: root.right.next = p if root.left: if root.right: root.left.next = root.right else: root.left.next = p self.connect(root.right) self.connect(root.left) return root 2. 迭代根据 BFS 进行层次遍历，具体实现过程如下： 12345678910111213141516171819202122232425262728293031323334353637383940"""# Definition for a Node.class Node: def __init__(self, val, left, right, next): self.val = val self.left = left self.right = right self.next = next"""class Solution: def connect(self, root: 'Node') -&gt; 'Node': if not root: return None queue = [[root]] while queue: top = queue.pop() level_node = [] pre = None for node in top: if node.left: level_node.append(node.left) if not pre: pre = node.left else: pre.next = node.left pre = node.left if node.right: level_node.append(node.right) if not pre: pre = node.right else: pre.next = node.right pre = node.right if level_node: queue.insert(0, level_node) return root]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Populating Next Right Pointers in Each Node]]></title>
    <url>%2F2019%2F03%2F05%2Fleetcode-PopulatingNextRightPointersinEachNode%2F</url>
    <content type="text"><![CDATA[Populating Next Right Pointers in Each NodeYou are given a perfect binary tree where all leaves are on the same level, and every parent has two children. Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.（连接完全二叉树同一层的结点） Example: 1. 递归在递归的过程中需要考虑左、右子树，兄弟结点之间的连接。具体实现过程如下： 1234567891011121314151617181920212223242526"""# Definition for a Node.class Node: def __init__(self, val, left, right, next): self.val = val self.left = left self.right = right self.next = next"""class Solution: def connect(self, root: 'Node') -&gt; 'Node': if not root or not root.left: return root # 左、右子树的连接 if root.left and root.right: root.left.next = root.right # 兄弟节点的连接 if root.next and root.right: root.right.next = root.next.left self.connect(root.left) self.connect(root.right) return root 2. 迭代由于在递归的过程中会使用到栈，因此空间复杂度为 O(log(n))，为了实现空间复杂度为 O(1)，使用迭代的方法，具体实现过程如下： 1234567891011121314151617181920212223242526"""# Definition for a Node.class Node: def __init__(self, val, left, right, next): self.val = val self.left = left self.right = right self.next = next"""class Solution: def connect(self, root: 'Node') -&gt; 'Node': if not root: return root p_start = root while p_start.left: p_cur = p_start while p_cur: p_cur.left.next = p_cur.right if p_cur.next: p_cur.right.next = p_cur.next.left p_cur = p_cur.next p_start = p_start.left return root]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Distinct Subsequences]]></title>
    <url>%2F2019%2F03%2F05%2Fleetcode-DistinctSubsequences%2F</url>
    <content type="text"><![CDATA[Distinct SubsequencesGiven a string S and a string T, count the number of distinct subsequences of S which equals T. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).（有效子序列个数） Example: 1. 动态规划这个题也可以看做一个字符串匹配的问题，一般都可以使用动态规划求解。具体实现过程如下： 12345678910111213141516171819202122232425262728class Solution: def numDistinct(self, s: str, t: str) -&gt; int: # t 为空，则删除 s 中的所有元素，只有一种方案。 if not t: return 1 # t 不为空，s 为空，不可能匹配。 if not s: return 0 m, n = len(s), len(t) dp = [[0]* (n + 1) for _ in range(m + 1)] for i in range(m+1): for j in range(n+1): if i == 0 and j == 0: dp[i][j] = 1 elif i == 0: dp[i][j] = 0 elif j == 0: dp[i][j] = 1 else: # s[i-1] 不参与匹配 dp[i][j] = dp[i-1][j] # s[i-1] 和 t[j-1] 匹配 if s[i-1] == t[j-1]: dp[i][j] += dp[i-1][j-1] return dp[m][n]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>dynamic programming</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Flatten Binary Tree to Linked List]]></title>
    <url>%2F2019%2F03%2F05%2Fleetcode-FlattenBinaryTreetoLinkedList%2F</url>
    <content type="text"><![CDATA[Flatten Binary Tree to Linked ListGiven a binary tree, flatten it to a linked list in-place.（压平二叉树） Example: 1. 递归递归压平子树，然后将左子树放在右子树上，并将左子树置为None。然后找到叶子节点将原来的右子树连接在后面。具体实现过程如下： 1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def flatten(self, root: TreeNode) -&gt; None: """ Do not return anything, modify root in-place instead. """ if not root: return if root.left: self.flatten(root.left) if root.right: self.flatten(root.right) # move the left tree to the right, set left to None p_temp = root.right root.right = root.left root.left = None # find the leaf and link the right tree p_tail = root while p_tail.right: p_tail = p_tail.right p_tail.right = p_temp return]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Path Sum II]]></title>
    <url>%2F2019%2F03%2F05%2Fleetcode-PathSumII%2F</url>
    <content type="text"><![CDATA[Path Sum IIGiven a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. Note: A leaf is a node with no children.（二叉树路径和并返回相应路径） Example: 1. 递归这道题是很清晰的递归的问题，需要注意的是节点的值可能是负值。具体实现方法如下： 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]: def path_helper(head, path, sum): if sum == head.val and not head.left and not head.right: self.paths.append(path+[head.val]) return if head.left: path_helper(head.left, path+[head.val], sum-head.val) if head.right: path_helper(head.right, path+[head.val], sum-head.val) if not root: return [] self.paths = [] path_helper(root, [], sum) return self.paths]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Path Sum]]></title>
    <url>%2F2019%2F03%2F05%2Fleetcode-PathSum%2F</url>
    <content type="text"><![CDATA[Path SumGiven a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children.（二叉树路径和） Example: 1. 递归1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool: if not root: return False # must be leaf if root.val == sum and not root.left and not root.right: return True return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>dfs</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Minimum Depth of Binary Tree]]></title>
    <url>%2F2019%2F03%2F05%2Fleetcode-MinimumDepthofBinaryTree%2F</url>
    <content type="text"><![CDATA[Minimum Depth of Binary TreeGiven a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children.（二叉树的最低深度） Example: 1. 递归注意左（右）子树深度为0的地方，也就是当左（右）子树为空时，应该按照右（左）子树的深度计算。具体实现过程如下： 1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def minDepth(self, root: TreeNode) -&gt; int: if not root: return 0 left, right = self.minDepth(root.left), self.minDepth(root.right) if left == 0 or right == 0: return left + right + 1 return min(left, right) + 1]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Balanced Binary Tree]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode-BalancedBinaryTree%2F</url>
    <content type="text"><![CDATA[Balanced Binary TreeGiven a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1.（判断是否是平衡二叉树） Example: 1. 递归123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isBalanced(self, root: TreeNode) -&gt; bool: def depth(root): if not root: return 0 return 1 + max(depth(root.left), depth(root.right)) if not root: return True if abs(depth(root.left) - depth(root.right)) &gt; 1: return False return self.isBalanced(root.left) and self.isBalanced(root.right)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>dfs</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Convert Sorted List to Binary Search Tree]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode-ConvertSortedListtoBinarySearchTree%2F</url>
    <content type="text"><![CDATA[Convert Sorted List to Binary Search TreeGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.（将有序链表转换为平衡二叉树） Example: 1. 递归首先获得链表的长度，然后根据中序遍历的过程不断地建立二叉树，这是一种自底向上的方法。先递归构建左子树，一直到左叶子节点，左叶子节点对应的就是链表的第一个元素，生成左叶子节点之后移动链表当前指针。其时间复杂度为O(n), 具体实现过程如下： 123456789101112131415161718192021222324252627282930313233343536373839# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = None# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def dfs(self, head, count): if count &lt;= 0: return None left = self.dfs(head, count // 2) root = TreeNode(self.curNode.val) self.curNode = self.curNode.next right = self.dfs(self.curNode, count - count // 2 - 1) root.left = left root.right = right return root def sortedListToBST(self, head: ListNode) -&gt; TreeNode: if not head: return None p = head count = 0 while p: count += 1 p = p.next self.curNode = head return self.dfs(head, count)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>easy</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode-ConvertSortedArraytoBinarySearchTree%2F</url>
    <content type="text"><![CDATA[Convert Sorted Array to Binary Search TreeGiven an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.（将有序数组转换为平衡二叉树） Example: 1. 递归根据平衡二叉树的定义：height差不大于1。因此从中间开始建立为根节点，左边的有序数组构建左子树，右边的有序数组构建右子树。具体实现过程如下： 123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: if not nums: return None n = len(nums) root = TreeNode(nums[n//2]) root.left = self.sortedArrayToBST(nums[:n//2]) root.right = self.sortedArrayToBST(nums[n//2+1:]) return root]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>dfs</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Binary Tree Level Order Traversal II]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode-BinaryTreeLevelOrderTraversalII%2F</url>
    <content type="text"><![CDATA[Binary Tree Level Order Traversal IIGiven a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).（从底向上按层遍历二叉树） Example: 1. 递归按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列。（变形之后的BFS）。(只需要把Binary Tree Level Order Traversal结果倒叙存储即可) 具体实现过程如下： 123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] results = [[root.val]] queue = [] queue.append([root]) while len(queue): top = queue.pop() result = [] level_node = [] for node in top: if node.left: level_node.append(node.left) result.append(node.left.val) if node.right: level_node.append(node.right) result.append(node.right.val) if result: queue.insert(0, level_node) results.insert(0, result) return results]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>bfs</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode-ConstructBinaryTreefromInorderandPostorderTraversal%2F</url>
    <content type="text"><![CDATA[Construct Binary Tree from Inorder and Postorder TraversalGiven inorder and postorder traversal of a tree, construct the binary tree.（根据中序遍历和后序遍历构建二叉树） Example: 1. 递归递归构建二叉树，首先根据后序遍历确定根节点，在根据中序遍历定位到根节点。其中，中序遍历根节点左边的为左子树，右边的为右子树。具体实现过程如下： 12345678910111213141516171819# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: if not inorder: return None root = TreeNode(postorder[-1]) index = inorder.index(postorder[-1]) root.left = self.buildTree(inorder[:index], postorder[:index]) root.right = self.buildTree(inorder[index+1:], postorder[index:-1]) return root]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode-ConstructBinaryTreefromPreorderandInorderTraversal%2F</url>
    <content type="text"><![CDATA[Construct Binary Tree from Preorder and Inorder TraversalGiven preorder and inorder traversal of a tree, construct the binary tree.（根据先序遍历和中序遍历构建二叉树） Example: 1. 递归递归构建二叉树，首先根据先序遍历确定根节点，在根据中序遍历定位到根节点。其中，中序遍历根节点左边的为左子树，右边的为右子树。具体实现过程如下： 12345678910111213141516171819# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: if not preorder: return None root = TreeNode(preorder[0]) index = inorder.index(preorder[0]) root.left = self.buildTree(preorder[1:index+1], inorder[:index]) root.right = self.buildTree(preorder[index+1:], inorder[index+1:]) return root]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Maximum Depth of Binary Tree]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode-MaximumDepthofBinaryTree%2F</url>
    <content type="text"><![CDATA[Maximum Depth of Binary TreeGiven a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.（二叉树的深度） Example: 1. 递归找到左子树和右子树的最大深度，从而返回该深度+1即为结果。具体实现过程如下： 123456789101112131415# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 max_depth = max(self.maxDepth(root.left), self.maxDepth(root.right)) return max_depth + 1]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>dfs</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode-BinaryTreeZigzagLevelOrderTraversal%2F</url>
    <content type="text"><![CDATA[Binary Tree Zigzag Level Order TraversalGiven a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).（按层从左到右-&gt;从右到左遍历二叉树） Example: 1. 递归与上一题类似，按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列，并在偶数行翻转（变形之后的BFS）。 123456789101112131415161718192021222324252627282930313233343536373839# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] results = [[root.val]] queue = [[root]] reverse_flag = 1 while len(queue) &gt; 0: top = queue.pop() result = [] level_node = [] for node in top: if node.left: level_node.append(node.left) result.append(node.left.val) if node.right: level_node.append(node.right) result.append(node.right.val) if result: if reverse_flag: result.reverse() reverse_flag = 1 - reverse_flag queue.insert(0, level_node) results.append(result) return results]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>bfs</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Binary Tree Level Order Traversal]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode-BinaryTreeLevelOrderTraversal%2F</url>
    <content type="text"><![CDATA[Binary Tree Level Order TraversalGiven a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).（按层遍历二叉树） Example: 1. 递归按层遍历，每次都把同层的树节点 Node 组合成一个 List 输入到队列。（变形之后的BFS）。 123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] results = [[root.val]] queue = [] queue.append([root]) while len(queue): top = queue.pop() result = [] level_node = [] for node in top: if node.left: level_node.append(node.left) result.append(node.left.val) if node.right: level_node.append(node.right) result.append(node.right.val) if result: queue.insert(0, level_node) results.append(result) return results]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Symmetric Tree]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode-SymmetricTree%2F</url>
    <content type="text"><![CDATA[Symmetric TreeGiven a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).（对称二叉树） Example: 1. 递归递归很常见，具体实现过程如下： 123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: def mirror(left, right): if not left and not right: return True if not left or not right: return False return left.val == right.val and mirror(left.left, right.right) and mirror(right.left, left.right) if not root: return True return mirror(root.left, root.right) 2. 迭代维护两个队列或者栈，把左子树放入第一个队列（先放左子树），右子树放入第二个队列（先放右子树），每次取队首（栈顶）元素进行判断。（使用队列表示BFS，使用栈表示DFS）具体实现过程如下： 1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# BFSclass Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: if not root: return True left_queue, right_queue = [root.left], [root.right] while len(left_queue) and len(right_queue): left_top = left_queue.pop() right_top = right_queue.pop() if not left_top and not right_top: continue if not left_top or not right_top: return False if left_top.val != right_top.val: return False left_queue.insert(0, left_top.left) left_queue.insert(0, left_top.right) right_queue.insert(0, right_top.right) right_queue.insert(0, right_top.left) return len(left_queue) == 0 and len(right_queue) == 0 1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# DFSclass Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: if not root: return True left_stack, right_stack = [root.left], [root.right] while len(left_stack) and len(right_stack): left_top = left_stack.pop() right_top = right_stack.pop() if not left_top and not right_top: continue if not left_top or not right_top: return False if left_top.val != right_top.val: return False left_stack.append(left_top.left) left_stack.append(left_top.right) right_stack.append(right_top.right) right_stack.append(right_top.left) return len(left_stack) == 0 and len(right_stack) == 0]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Same Tree]]></title>
    <url>%2F2019%2F02%2F27%2Fleetcode-SameTree%2F</url>
    <content type="text"><![CDATA[Same TreeGiven two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.（判断二叉树是否相同） Example: 1. 递归判断节点值，左子树，右子树是否一致，具体实现方法如下： 12345678910111213141516# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool: if not p and not q: return True if not p or not q: return False if p.val != q.val: return False return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>dfs</tag>
        <tag>easy</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Recover Binary Search Tree]]></title>
    <url>%2F2019%2F02%2F27%2Fleetcode-RecoverBinarySearchTree%2F</url>
    <content type="text"><![CDATA[Recover Binary Search TreeTwo elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure.（复原二叉排序树） Follow Up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? Example: 1. 中序遍历 &amp; 树-&gt;数组中序遍历二叉树，保存所有的节点到数组；然后遍历数组查找不符合要求的节点指针，空间复杂度为 O(n)。具体实现方法如下： 1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def recoverTree(self, root: TreeNode) -&gt; None: """ Do not return anything, modify root in-place instead. """ def treelist(root): if not root: return treelist(root.left) tree_list.append(root) treelist(root.right) tree_list = [] treelist(root) first_node, second_node = None, None for i in range(len(tree_list) - 1): if tree_list[i+1].val &lt;= tree_list[i].val: if not first_node: first_node = tree_list[i] second_node = tree_list[i+1] else: second_node = tree_list[i+1] first_node.val, second_node.val = second_node.val, first_node.val 2. 中序遍历题中的 Follow Up 提及最好是空间复杂度为 O(1)，因此在中序遍历的过程中需要同时找出不符合要求的节点指针。具体实现方法如下： 1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def recoverTree(self, root: TreeNode) -&gt; None: """ Do not return anything, modify root in-place instead. """ def dfs(root): if not root: return dfs(root.left) if self.prev and self.prev.val &gt;= root.val and self.first_node == None: self.first_node = self.prev if self.prev and self.prev.val &gt;= root.val and self.first_node != None: self.second_node = root self.prev = root dfs(root.right) self.prev = None self.first_node = None self.second_node = None dfs(root) self.first_node.val, self.second_node.val = self.second_node.val, self.first_node.val]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Validate Binary Search Tree]]></title>
    <url>%2F2019%2F02%2F27%2Fleetcode-ValidateBinarySearchTree%2F</url>
    <content type="text"><![CDATA[Validate Binary Search TreeGiven a binary tree, determine if it is a valid binary search tree (BST).（判断是否为二叉排序树） Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example: 1. 递归需要注意的是，在判断子树是否为二叉排序树时，我们需要考虑子树上的节点都小于（或大于）根节点，因此需要传入阈值。具体实现方法如下： 1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isValidBST(self, root: TreeNode) -&gt; bool: def _isValidBST(root, _min=float('-inf'), _max=float('inf')): if not root: return True if root.val &lt;= _min or root.val &gt;= _max: return False return _isValidBST(root.left, _min, root.val) and \ _isValidBST(root.right, root.val, _max) return _isValidBST(root) 2. DFS &amp; Inorder（中序遍历）首先对二叉树进行中序遍历，然后对遍历的结果判断是否是一个完全递增的序列（不可相等），具体实现方法如下： 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isValidBST(self, root: TreeNode) -&gt; bool: def dfs(root): if not root: return dfs(root.left) self.travel.append(root.val) dfs(root.right) self.travel = [] dfs(root) for i in range(len(self.travel) - 1): if self.travel[i+1] &lt;= self.travel[i]: return False return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Interleaving String]]></title>
    <url>%2F2019%2F02%2F27%2Fleetcode-InterleavingString%2F</url>
    <content type="text"><![CDATA[Interleaving StringGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.（判断s1 与 s2 相互插入可否组成 s3） Example: 字符串匹配 &amp; 动态规划 死锁 1. 动态规划dp[i][j]表示用 s1 的前 i 个字符和 s2 的前 j 个字符能不能按照规则表示出 s3 的前 i+j 个字符。递推表达式为：dp[i][j] = (dp[i][j-1] and s2[j-1] == s3[i + j -1]) or (dp[i-1][j] and s1[i-1] == s3[i + j -1])其中需要注意维护边界，具体实现过程如下： 1234567891011121314151617181920class Solution: def isInterleave(self, s1: str, s2: str, s3: str) -&gt; bool: len1, len2, len3 = len(s1), len(s2), len(s3) if len1 + len2 != len3: return False dp = [[False] * (len2 + 1) for _ in range(len1 + 1)] for i in range(len1+1): for j in range(len2+1): if i==0 and j==0: dp[i][j] = True elif i==0: dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1] elif j==0: dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1] else: dp[i][j] = (dp[i][j-1] and s2[j-1] == s3[i + j -1]) or (dp[i-1][j] and s1[i-1] == s3[i + j -1]) return dp[len1][len2]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Unique Binary Search Trees]]></title>
    <url>%2F2019%2F02%2F27%2Fleetcode-UniqueBinarySearchTrees%2F</url>
    <content type="text"><![CDATA[Unique Binary Search TreesGiven an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.（有效二叉查找(排序)树个数） Example: 1. 动态规划这道题实质上是 卡塔兰数 的一个实例。具体递推过程如下： 1234567891011 1 n = 1 2 1 n = 2 / \ 1 21 3 3 2 1 n = 3 \ / / / \ \ 3 2 1 1 3 2 / / \ \2 1 2 3 n=0 时，dp[0] = 1 n=1 时，dp[1] = 1 n=2 时，dp[2] = dp[0]*dp[1] + dp[1]*dp[0] （以1为根 + 以2为根） n&gt;=2 时，dp[n] = dp[0]*dp[n-1] + dp[1]*dp[n-2] + … + dp[n-1]*dp[0] 12345678910class Solution: def numTrees(self, n: int) -&gt; int: dp = [0 for _ in range(n+1)] dp[0], dp[1] = 1, 1 for i in range(2, n+1): for j in range(i): dp[i] += dp[j] * dp[i-j-1] return dp[n]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Unique Binary Search Trees II]]></title>
    <url>%2F2019%2F02%2F27%2Fleetcode-UniqueBinarySearchTreesII%2F</url>
    <content type="text"><![CDATA[Unique Binary Search Trees IIGiven an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.（构建二叉查找(排序)树） Example: 1. 递归递归的构建左子树 和 右子树，具体实现方法如下： Note: 在start &gt; end 的时候，不存在这样的子树。 123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def generateTrees(self, n: int) -&gt; List[TreeNode]: def gen(start, end): if start &gt; end: return [None] results = [] for i in range(start, end+1): for l in gen(start, i-1): for r in gen(i+1, end): t = TreeNode(i) t.left = l t.right = r results.append(t) return results if n &lt; 1: return [] return gen(1, n)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>tree</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Binary Tree Inorder Traversal]]></title>
    <url>%2F2019%2F02%2F27%2Fleetcode-BinaryTreeInorderTraversal%2F</url>
    <content type="text"><![CDATA[Binary Tree Inorder TraversalGiven a binary tree, return the inorder traversal of its nodes’ values.（中序遍历二叉树） Follow up: Recursive solution is trivial, could you do it iteratively? Example: 1. 递归具体实现方法如下： 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def inorder(self, tree): if not tree: return if tree.left: self.inorder(tree.left) self.results.append(tree.val) if tree.right: self.inorder(tree.right) def inorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] self.results = [] self.inorder(root) return self.results 2. 迭代 &amp; 栈不断将左子树加入到栈中，然后访问依次访问，最后再访问右子树。具体实现方法如下：1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] results, stack = [], [] p = root while stack or p: while p: stack.append(p) p = p.left p = stack.pop() results.append(p.val) p = p.right return results]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>hash table</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Restore IP Addresses]]></title>
    <url>%2F2019%2F02%2F27%2Fleetcode-RestoreIPAddresses%2F</url>
    <content type="text"><![CDATA[Restore IP AddressesGiven a string containing only digits, restore it by returning all possible valid IP address combinations.（IP地址规则化） Example: 1. 回溯法 / DFS很自然的使用回溯法来解决这个问题。其中，需要考虑到的问题是： ip地址为4段，每段在[0,255]区间内； 每段可以是0，但是其长度大于1时，不能以0开头。具体实现过程如下： 1234567891011121314151617181920212223242526272829class Solution: def dfs(self, string, part, count): re = ".".join(part) if count == 4 and not string and re not in self.results: self.results.append(re) for j in range(len(string)): # count = 4 才满足ip的4段地址，新划分的string[:j+1]不为空，且在0-255之间 if count &lt;= 3 and string[:j+1] and int(string[:j+1]) &lt;= 255 \ # string[:j+1]长度为1 或 string[:j+1]长度大于1但不能以0开头 and (j+1 &lt; 2 or (j+1 &gt;= 2 and string[0] != '0')): self.dfs(string[j+1:], part + [string[:j+1]], count + 1) # for i in range(1, 4): # if i &lt;= len(string): # if i == 1: # self.dfs(string[i:], part + [string[:i]], count + 1) # if i==2 and string[0] != '0': # self.dfs(string[i:], part + [string[:i]], count + 1) # if i==3 and string[0] != '0' and int(string[:3]) &lt;= 255 : # self.dfs(string[i:], part + [string[:i]], count + 1) def restoreIpAddresses(self, s: str) -&gt; List[str]: if not s or len(s) &gt; 12: return [] self.results = [] self.dfs(s, [], 0) return self.results]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>back tracking</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Reverse Linked List II]]></title>
    <url>%2F2019%2F02%2F26%2Fleetcode-ReverseLinkedListII%2F</url>
    <content type="text"><![CDATA[Reverse Linked List IIReverse a linked list from position m to n. Do it in one-pass.（旋转link_list[m:n+1]） Note: 1 ≤ m ≤ n ≤ length of list. Example: 1. In-place具体实现方法如下： 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode: new_head = ListNode(0) new_head.next = head p_pre = new_head p_cur = head for i in range(1, m): p_pre = p_pre.next p_cur = p_cur.next for j in range(n-m): p_head = p_pre.next p_pre.next = p_cur.next p_temp = p_cur.next p_cur.next = p_cur.next.next p_temp.next = p_head return new_head.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Decode Ways]]></title>
    <url>%2F2019%2F02%2F26%2Fleetcode-DecodeWays%2F</url>
    <content type="text"><![CDATA[Decode WaysA message containing letters from A-Z is mapped to 1-26, Given a non-empty string containing only digits, determine the total number of ways to decode it.（解码方法） Example: 1. 动态规划对于扫描的第 i 个数字时，我们考虑其单独 mapping（dp[i] += dp[i-1]），或者 i-1 和 i 一起 mapping（dp[i] += dp[i-2]）。具体实现过程如下： 123456789101112131415class Solution: def numDecodings(self, s: str) -&gt; int: if s == '' or s == '0': return 0 n = len(s) dp = [1] + [0] * n for i in range(1, n+1): # if int(s[i-1:i]) != 0: if int(s[i-1:i]) &gt;=1 and int(s[i-1:i]) &lt;= 9: dp[i] += dp[i-1] if i&gt;=2 and int(s[i-2:i]) &gt;=10 and int(s[i-2:i]) &lt;= 26: dp[i] += dp[i-2] return dp[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Subsets II]]></title>
    <url>%2F2019%2F02%2F26%2Fleetcode-SubsetsII%2F</url>
    <content type="text"><![CDATA[Subsets IIGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).（列举所有子集） Note: The solution set must not contain duplicate subsets. Example: 1. 回溯法 / DFS123456789101112131415class Solution: def dfs(self, index, re): if sorted(re) not in self.results: self.results.append(sorted(re)) for i in range(index, len(self.nums)): self.dfs(i+1, re) self.dfs(i+1, re + [self.nums[i]]) def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: self.results = [] self.nums = nums self.dfs(0, []) return self.results]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_Gray Code]]></title>
    <url>%2F2019%2F02%2F25%2Fleetcode-GrayCode%2F</url>
    <content type="text"><![CDATA[Gray CodeThe gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.(n位格雷码) Example: 1. 二进制码转换为格雷码二进制转换为 Gray码：右移一位并与自身异或。如 n=2 时，binary=[00, 01, 10, 11], gray=[00^00, 00^01, 01^10, 01^11]=[11, 01, 11, 10]，即[0, 1, 3, 2]。 1234567class Solution: def grayCode(self, n: int) -&gt; List[int]: results = [] for i in range(pow(2, n)): results.append((i &gt;&gt; 1) ^ i) return results 2. 格雷码的镜面排列 n=0时，gray=[0] n=1时，add_gray=[0] + 2^0, gray=[0, 1] n=2时，add_gray=[1, 0] + 2^1, gray=[0, 1, 3, 2]… 1234567class Solution: def grayCode(self, n: int) -&gt; List[int]: results = [0] for i in range(n): results += [x+2**i for x in reversed(results)] return results]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>back tracking</tag>
        <tag>binary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Merge Sorted Array]]></title>
    <url>%2F2019%2F02%2F25%2Fleetcode-MergeSortedArray%2F</url>
    <content type="text"><![CDATA[Merge Sorted ArrayGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.(合并有序数组) Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: 1. 反向插入由于最终的数组的长度是已知的，我们可以直接从最后一个位置向前遍历，寻找最大值。具体实现过程如下： 1234567891011121314151617181920class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: """ Do not return anything, modify nums1 in-place instead. """ index = m + n - 1 while index &gt;= 0: if m &gt; 0 and n &gt; 0: if nums1[m-1] &gt; nums2[n-1]: nums1[index] = nums1[m-1] m -= 1 else: nums1[index] = nums2[n-1] n -= 1 index -= 1 elif n &gt; 0: nums1[: index+1] = nums2[: index+1] break else: break]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Scramble String]]></title>
    <url>%2F2019%2F02%2F25%2Fleetcode-ScrambleString%2F</url>
    <content type="text"><![CDATA[Scramble StringGiven two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.(判断一个字符串是否为另一个字符串“乱序”得到) Example: 1. 递归根据题意，加入 s1 和 s2 是 scramble 的话，那么必然存在一个在 s1 上的长度 l1，将 s1 分成 s11 和 s12 两段，同样有 s21 和 s22. 要么 s11 和 s21 是 scramble 的并且 s12 和 s22 是 scramble 的；要么 s11 和 s22 是 scramble 的并且 s12 和 s21 是 scramble 的。就拿题目中的例子 “rgeat” 和 “great” 来说，“rgeat” 可分成 “rg” 和 “eat” 两段，“great” 可分成 “gr” 和 “eat” 两段，“rg” 和 “gr” 是 scrambled 的，“eat” 和 “eat” 当然是 scrambled 。具体实现过程如下： 12345678910111213141516class Solution: def isScramble(self, s1: str, s2: str) -&gt; bool: if len(s1) != len(s2): return False if s1 == s2: return True sort_s1, sort_s2 = sorted(s1), sorted(s2) if sort_s1 != sort_s2: return False for i in range(1, len(s1)): if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \ (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:len(s1)-i])): return True return False 2. 动态规划这其实是一道三维动态规划的题目，我们提出维护量 res[i][j][n]，其中 i 是 s1 的起始字符，j 是 s2 的起始字符，而 n 是当前的字符串长度，res[i][j][length]表示的是以 i 和 j 分别为 s1 和 s2 起点的长度为 length 的字符串是不是互为scramble。其递推表达式为，对于所有的 1&lt;=k&lt;\length: res[i][j][length] = (res[i][j][k] &amp;&amp; res[i+k][j+k][length-k] || res[i][j+length-k][k] &amp;&amp; res[i+k][j][length-k])也就是对于所有 len-1 种劈法的结果求或运算。具体实现方法如下： 1234567891011121314151617181920212223class Solution: def isScramble(self, s1: str, s2: str) -&gt; bool: if len(s1) != len(s2): return False if s1 == s2: return True n = len(s1) dp = [[[False] * (n+1) for _ in range(n)] for _ in range(n)] for i in range(n): for j in range(n): if s1[i] == s2[j]: dp[i][j][1] = True for length in range(2, n+1): for i in range(n-length+1): for j in range(n-length+1): for k in range(1, length): if (dp[i][j][k] and dp[i+k][j+k][length-k]) or \ (dp[i][j+length-k][k] and dp[i+k][j][length-k]): dp[i][j][length] = True return dp[0][0][n]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>dynamic programming</tag>
        <tag>string</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Partition List]]></title>
    <url>%2F2019%2F02%2F25%2Fleetcode-PartitionList%2F</url>
    <content type="text"><![CDATA[Partition ListGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.(切分链表) Example: 1. 两个指针 In-place第一种是 in-place，具体实现过程如下： 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def partition(self, head: ListNode, x: int) -&gt; ListNode: new_head = ListNode(0) new_head.next = head p_pre = new_head p_cur = head p_insert = None while p_cur: if p_cur.val &gt;= x and not p_insert: p_insert = p_pre elif p_cur.val &lt; x: if p_insert: p_pre.next = p_cur.next p_cur.next = p_insert.next p_insert.next = p_cur p_cur = p_pre.next p_insert = p_insert.next continue p_pre = p_pre.next p_cur = p_cur.next return new_head.next 2. 两个指针第二种是新构建两个链表分别存储，具体实现过程如下： 123456789101112131415161718class Solution: def partition(self, head: ListNode, x: int) -&gt; ListNode: p_l = l_head = ListNode(0) p_r = r_head = ListNode(0) p_cur = head while p_cur: if p_cur.val &gt;= x: p_r.next = p_cur p_r = p_r.next else: p_l.next = p_cur p_l = p_l.next p_cur = p_cur.next p_l.next = r_head.next p_r.next = None return l_head.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>two pointers</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Maximal Rectangle]]></title>
    <url>%2F2019%2F02%2F25%2Fleetcode-MaximalRectangle%2F</url>
    <content type="text"><![CDATA[Maximal RectangleGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.(最大矩形) Follow up: Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area. Example: 1. 问题转换 &amp; 栈基于上一题，Largest Rectangle in Histogram，我们可以考虑将这题中的求最大矩形面积转换为直方图中的求最大矩形的面积。通过遍历矩阵的每一行，将矩阵中纵列 “1” 的序列长度表示为直方图的高度，也就是我们求 m 个直方图中的最大矩形面积。具体实现过程如下： 123456789101112131415161718class Solution: def maximalRectangle(self, matrix: List[List[str]]) -&gt; int: if not matrix or not matrix[0]: return 0 n = len(matrix[0]) height = [0] * (n + 1) ans = 0 for row in matrix: for i in range(n): height[i] = height[i] + 1 if row[i] == '1' else 0 stack = [-1] for i in range(n + 1): while height[i] &lt; height[stack[-1]]: h = height[stack.pop()] w = i - 1 - stack[-1] ans = max(ans, h * w) stack.append(i) return ans 2. 动态规划这道题的动态规划的算法方面不太好理解，不能直接用二维动规来解决问题。具体实现过程如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def maximalRectangle(self, matrix: 'List[List[str]]') -&gt; 'int': if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # 对每一行进行计算, 递推公式如下: # 每一行开始时,左边界 left 定为0, 右边界 right 定为n # height[j]好算: # 如果matrix[i][j] = 0, height[j] = 0 # 如果matrix[i][j] = 1, height[j]++ # left[j]从左往右算: # 如果matrix[i][j] = 0, left[j]=0, 同时cur_left变为当前j+1(因为潜在的左边界可能就在j+1) # 如果matrix[i][j] = 1, left[j]= max(left[j], cur_left), 哪个大取哪个. # (解释: 因为我们要的是过往所有行中0到该列位置最晚遇到1的位置) # right[j]从右往左算: # 如果matrix[i][j] = 0, right[j]=n, 同时cur_right变为当前j(因为潜在的右边界就在当前j位置) # 如果matrix[i][j] = 1, right[j]= min(right[j], cur_right), 哪个小取哪个. # (解释: 因为我们要的是过往所有行中COL-1到该列位置最早遇到0的位置) left = [0 for _ in range(n)] right = [n for _ in range(n)] height = [0 for _ in range(n)] max_res = 0 for i in range(m): cur_left = 0 cur_right = n for j in range(n): if matrix[i][j] == '1': height[j] += 1 left[j] = max(left[j], cur_left) else: height[j] = 0 left[j] = 0 cur_left = j + 1 for j in range(n-1, -1, -1): if matrix[i][j] == '1': right[j] = min(right[j], cur_right) else: right[j] = n cur_right = j for j in range(n): max_res = max(max_res, (right[j] - left[j]) * height[j]) return max_res]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
        <tag>hash table</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Largest Rectangle in Histogram]]></title>
    <url>%2F2019%2F02%2F23%2Fleetcode-LargestRectangleinHistogram%2F</url>
    <content type="text"><![CDATA[Largest Rectangle in HistogramGiven n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.（在条形图中取最大矩形面积） Example: 1. 堆栈维护一个栈来存储升序序列，当遇到当前 height 小于栈顶 height 时，考虑计算。以栈顶的高度为高，栈顶 index 到 i-1 为宽的矩形。其中在pop过程中栈顶为空时，则需要将其维护为 “-1”，因为当 stack 为空时，说明数组中的最小值（所有高度中的最小值已经pop出来了，因此前面的所有都可以算作面积）。其时间复杂度为O(n)，空间复杂度为O(n)。具体实现过程如下： Note: 在 heights 尾部增加一个 “0” 是为了防止在数组尾部的最后一个升序序列没有计算，如[3, 4, 1, 3, 5, 7]。 stack 存储的是 index 是为了方便计算矩形的 width。 可以事先维护 stack 为 [-1]，这样就不用考虑单独 stack 为空的情况了。 12345678910111213141516class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: stack = [] result = 0 heights.append(0) for i, height in enumerate(heights): while len(stack) &gt; 0 and height &lt; heights[stack[-1]]: top = stack.pop() if len(stack) == 0: start = -1 else: start = stack[-1] result = max(result, heights[top] * (i-1-start)) stack.append(i) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>array</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Remove Duplicates from Sorted List]]></title>
    <url>%2F2019%2F02%2F23%2Fleetcode-RemoveDuplicatesfromSortedList%2F</url>
    <content type="text"><![CDATA[Remove Duplicates from Sorted ListGiven a sorted linked list, delete all duplicates such that each element appear only once.（移除链表中的重复元素（所有元素只出现一次）） Example: 1. 指针遍历在遍历过程中维护一个 p_pre 来记录重复元素之前的位置。具体实现过程如下： 123456789101112131415class Solution: def deleteDuplicates(self, head: ListNode) -&gt; ListNode: new_head = ListNode(0) new_head.next = head p_pre = new_head p_cur = new_head.next while p_cur != None: while p_cur.next and p_cur.val == p_cur.next.val: p_cur = p_cur.next p_pre.next = p_cur p_pre = p_cur p_cur = p_cur.next return new_head.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Remove Duplicates from Sorted List II]]></title>
    <url>%2F2019%2F02%2F23%2Fleetcode-RemoveDuplicatesfromSortedListII%2F</url>
    <content type="text"><![CDATA[Remove Duplicates from Sorted List IIGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.（移除链表中的重复元素（删除出现2次以上的元素）） Example: 1. 指针遍历在遍历过程中维护一个 p_pre 来记录重复元素之前的位置。具体实现过程如下： 1234567891011121314151617class Solution: def deleteDuplicates(self, head: ListNode) -&gt; ListNode: new_head = ListNode(0) new_head.next = head p_pre = new_head p_cur = new_head.next while p_cur != None: while p_cur.next and p_cur.val == p_cur.next.val: p_cur = p_cur.next if p_pre.next == p_cur: p_pre = p_cur else: p_pre.next = p_cur.next p_cur = p_cur.next return new_head.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Search in Rotated Sorted Array II]]></title>
    <url>%2F2019%2F02%2F23%2Fleetcode-SearchinRotatedSortedArrayII%2F</url>
    <content type="text"><![CDATA[Search in Rotated Sorted Array IISuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false.（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索(数组中含有重复元素)） Example: 1. 二分查找定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。其中由于可能含有重复元素，需要跳过。具体实现如下： 123456789101112131415161718192021222324252627282930313233343536class Solution: def search(self, nums: List[int], target: int) -&gt; bool: """ :type nums: List[int] :type target: int :rtype: int """ if not nums: return False left = 0 right = len(nums)-1 while left &lt;= right: middle = (left + right) // 2 if target == nums[middle]: return True while left &lt; middle and nums[left] == nums[middle]: left += 1 while right &gt; middle and nums[right] == nums[middle]: right -= 1 if nums[left] &lt;= nums[middle]: if target &lt; nums[middle] and target &gt;= nums[left]: right = middle - 1 else: left = middle + 1 else: if target &gt; nums[middle] and target &lt;= nums[right]: left = middle + 1 else: right = middle - 1 return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Remove Duplicates from Sorted Array II]]></title>
    <url>%2F2019%2F02%2F23%2Fleetcode-RemoveDuplicatesfromSortedArrayII%2F</url>
    <content type="text"><![CDATA[Remove Duplicates from Sorted Array IIGiven a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.（删除数组中超过两次的元素，in-place, 限制空间复杂度） Example: 1. 重复元素个数需要维护一个变量来记录在遍历过程中数字是重复次数k，以及元素需要前移的步数move_before。具体实现过程如下： 123456789101112131415161718192021222324class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: if len(nums) &lt;= 2: return k, move_before = 0, 0 now = None for i, num in enumerate(nums): if num != now: now = num if k &gt; 2: move_before += k-2 k = 1 else: k += 1 nums[i-move_before] = num # last item if k &gt; 2: move_before += k-2 nums[i-move_before] = num return len(nums) - move_before]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Word Search]]></title>
    <url>%2F2019%2F02%2F23%2Fleetcode-WordSearch%2F</url>
    <content type="text"><![CDATA[Word SearchGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.（矩阵中进行词语搜索） Example: 1. 回溯法 / DFS12345678910111213141516171819202122232425262728293031323334353637class Solution: def dfs(self, i, j, word): if word == '': return True tmp = self.board[i][j] self.board[i][j] = '0' if i&gt;0 and self.board[i-1][j] == word[0]: if self.dfs(i-1, j, word[1:]): return True if j&gt;0 and self.board[i][j-1] == word[0]: if self.dfs(i, j-1, word[1:]): return True if i&lt;len(self.board)-1 and self.board[i+1][j] == word[0]: if self.dfs(i+1, j, word[1:]): return True if j&lt;len(self.board[0])-1 and self.board[i][j+1] == word[0]: if self.dfs(i, j+1, word[1:]): return True self.board[i][j] = tmp return False def exist(self, board: List[List[str]], word: str) -&gt; bool: if not word: return True if not board or not board[0]: return False self.board = board for i in range(len(self.board)): for j in range(len(self.board[0])): if self.board[i][j] == word[0]: if self.dfs(i, j, word[1:]): return True return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Subsets]]></title>
    <url>%2F2019%2F02%2F23%2Fleetcode-Subsets%2F</url>
    <content type="text"><![CDATA[SubsetsGiven a set of distinct integers, nums, return all possible subsets (the power set).（列举所有子集） Example: 1. 回溯法 / DFS具体实现方法如下： 123456789101112131415161718class Solution: def dfs(self, i, re): if re not in self.result: self.result.append(re) for j in range(i, self.n): self.dfs(j+1, re + [self.nums[j]]) self.dfs(j+1, re) def subsets(self, nums: List[int]) -&gt; List[List[int]]: self.nums = nums self.n = len(nums) self.result = [] self.dfs(0, []) return self.result 2. 递归求子集的过程中，list 中的每一个元素要么出现，要么不出现。可以通过递归的方法，增加一个元素，即是原来的子集 + 子集中的每一个集合加上这个新元素的组合。具体实现过程如下： 1234567class Solution: def subsets(self, nums: 'List[int]') -&gt; 'List[List[int]]': res = [[]] for num in sorted(nums): res += [item+[num] for item in res] return res]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>back tracking</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Combinations]]></title>
    <url>%2F2019%2F02%2F23%2Fleetcode-Combinations%2F</url>
    <content type="text"><![CDATA[CombinationsGiven two integers n and k, return all possible combinations of k numbers out of 1 … n.（列举 C_n^k 的所有组合） Example: 1. 回溯法 / DFS具体实现方法如下： 12345678910111213class Solution: def dfs(self, i, re_list): if len(re_list) == self.k: self.result.append(re_list) for j in range(i, self.n + 1): self.dfs(j + 1, re_list + [j]) def combine(self, n: int, k: int) -&gt; List[List[int]]: self.n = n self.k = k self.result = [] self.dfs(1, []) return self.result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Minimum Window Substring]]></title>
    <url>%2F2019%2F02%2F22%2Fleetcode-MinimumWindowSubstring%2F</url>
    <content type="text"><![CDATA[Minimum Window SubstringGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).（包含字符串的最小窗口） Note: If there is no such window in S that covers all characters in T, return the empty string “”. If there is such window, you are guaranteed that there will always be only one unique minimum window in S. Example: 1. 哈希表 &amp; 双指针很直观，这题需要用到 HashMap 来存储目标字符串。用 left，right 两个指针指向 S，在遍历 S 的过程中，right 不断地右移来找到复合要求的字符串，也就是 required_char == 0 的时候，考虑向右移动 left，直到发现了当前的 S[left: right+1] 不符合要求的时候，重新向右移动 right。具体实现过程如下： 1234567891011121314151617181920212223242526272829303132333435363738394041import collectionsclass Solution: def minWindow(self, s: 'str', t: 'str') -&gt; 'str': if not s or not t: return "" t_dict = collections.Counter(t) required_char = len(t_dict) len_s = len(s) re_len, re = len_s + 1, "" left, right = 0, 0 while right &lt; len_s: if s[right] not in t_dict: right += 1 continue t_dict[s[right]] -= 1 if t_dict[s[right]] == 0: required_char -= 1 while required_char == 0: if right - left + 1 &lt; re_len: re = s[left: right + 1] re_len = right - left + 1 if s[left] not in t_dict: left += 1 continue t_dict[s[left]] += 1 if t_dict[s[left]] == 1: required_char += 1 left += 1 right += 1 if re_len == len_s + 1: return "" return re]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>hash table</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Sort Colors]]></title>
    <url>%2F2019%2F02%2F21%2Fleetcode-SortColors%2F</url>
    <content type="text"><![CDATA[Sort ColorsGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.(in-place 分组排序) Note: You are not suppose to use the library’s sort function for this problem. Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with a one-pass algorithm using only constant space? Example: 1. 首尾指针在一开始，两个指针是指向数组的头和尾的，可以看做是排好序的“0”序列的后一个数和“2”序列的前一个数。遍历数组当遇到“0”时，将其和“0”序列后面一个数交换，然后“0”序列的指针向后移。当遇到“2”时，将其和“2”序列前面一个数交换，然后将“2”序列的指针向前移。遇到“1”时，不做处理。这样，当我们遍历到2序列开头时，实际上我们已经排好序了，因为所有“0”都被交换到了前面，所有“2”都被交换到了后面。 (这里需要注意的是当遇到“2”时并交换数值之后，我们还不能确定换来的就是“0”“1”“2”，需要重新检测一次。) 其时间复杂度为O(N)，空间复杂度为O(1)。 123456789101112131415161718class Solution: def sortColors(self, nums: 'List[int]') -&gt; 'None': """ Do not return anything, modify nums in-place instead. """ n = len(nums) left, right, i = 0, n - 1, 0 while i &lt;= right: if nums[i] == 0: nums[i], nums[left] = nums[left], nums[i] left += 1 i += 1 elif nums[i] == 2: nums[i], nums[right] = nums[right], nums[i] right -= 1 else: i += 1 2. 遍历两次根据题中的Follow Up, 我们可以在第一次遍历过程中分别记录“0”“1”“2”的个数，在第二次遍历过程中一次替换即可。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Search A 2D Matrix]]></title>
    <url>%2F2019%2F02%2F21%2Fleetcode-SearchA2dMatrix%2F</url>
    <content type="text"><![CDATA[Search A 2D MatrixWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.(查找数值是否在有序矩阵中) Example: 1. 二分查找123456789101112131415161718192021class Solution: def searchMatrix(self, matrix: 'List[List[int]]', target: 'int') -&gt; 'bool': if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) left, right = 0, m * n -1 while left &lt;= right: middle = (left + right) // 2 row, col = middle // n, middle % n if target == matrix[row][col]: return True elif target &gt; matrix[row][col]: left = middle + 1 else: right = middle - 1 return False Note: 注意矩阵为空的情况哦~]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Edit Distance]]></title>
    <url>%2F2019%2F02%2F19%2Fleetcode-EditDistance%2F</url>
    <content type="text"><![CDATA[Edit DistanceGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2.（计算编辑距离） You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example: 动态规划 时间复杂度 O(n^2) 空间间复杂度 O(n^2)很明显的动态规划的题目，问题就在于需要分类讨论。具体的讨论情况在code的注释部分有详细解释。 12345678910111213141516171819202122232425class Solution: def minDistance(self, word1: 'str', word2: 'str') -&gt; 'int': len1 = len(word1) len2 = len(word2) # Create a table to store results of subproblems dp = [[0 for _ in range(len1 + 1)] for _ in range(len2 + 1)] for i in range(len2 + 1): for j in range(len1 + 1): # word1 is empty, insert all chars if i == 0: dp[i][j] = j # word2 is empty, remove all chars elif j == 0: dp[i][j] = i # last chars are same elif word2[i-1] == word1[j-1]: dp[i][j] = dp[i-1][j-1] # last chars are different, min(insert, remove, replace) else: dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) # return dp[len2][len1] return dp[-1][-1] 动态规划 时间复杂度 O(n^2) 空间间复杂度 O(n)1234567891011121314151617181920212223class Solution: def minDistance(self, word1: 'str', word2: 'str') -&gt; 'int': len1 = len(word1) len2 = len(word2) # Create a table to store results of subproblems dp = [0 for _ in range(len2 + 1)] for j in range(len2 + 1): dp[j] = j for i in range(1, len1 + 1): prev = i for j in range(1, len2 + 1): if word1[i-1] == word2[j-1]: cur = dp[j-1] else: cur = min(dp[j-1], dp[j], prev) + 1 dp[j-1] = prev prev = cur dp[len2] = prev return dp[len2]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>dynamic programming</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Text Justification]]></title>
    <url>%2F2019%2F02%2F19%2Fleetcode-TextJustification%2F</url>
    <content type="text"><![CDATA[Text Justification（文本左右对齐） Note: A word is defined as a character sequence consisting of non-space characters only. Each word’s length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word. Example: 字符串遍历具体考虑分析需要分为以下几步： 计算每行最多显示单词的数量，记录起始单词位置（结束指针单词不包含在内），这里要注意，单词与单词之间的都要求有空格，所以除了开始的单词，每个单词的长度还要加1 计算显示每句话需要的空格的数量 计算每句话中单词之间需要均匀填充的空格数量。这里要注意最后一行不需要进行均匀填充，不能均匀填充的空格数量要记录下来，优先分给左边的单词间空格 按照之前计算好的空格数量将单词连接成语句。 要考虑到最后一句是在最右端填充所有的空格 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def fullJustify(self, words, maxWidth): """ :type words: List[str] :type maxWidth: int :rtype: List[str] """ ans = [] i = 0 while i &lt; len(words): size = 0 begin = i # 确定每行的单词数 while i &lt; len(words): newsize = len(words[i]) if size == 0 else size + len(words[i]) + 1 if newsize &lt;= maxWidth: size = newsize i += 1 else: break # 计算需要的剩余的空格数 spaceCount = maxWidth - size # 计算每个单词需要的分配的单词数 if i - 1 - begin &gt; 0 and i &lt; len(words): # 不是最后一行 everyCount = spaceCount // (i - 1 - begin) spaceCount %= (i - 1 - begin) else: # 最后一行 everyCount = 0 # 根据空格数重新构建输出 j = begin s = '' while j &lt; i: if j &gt; begin: s += ' ' * (everyCount + 1) # 无法均匀分配的空格优先分配给左边 if spaceCount &gt; 0 and i &lt; len(words): s += ' ' spaceCount -= 1 s += words[j] j += 1 s += ' ' * spaceCount ans.append(s) return ans]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Set Matrix Zeroes]]></title>
    <url>%2F2019%2F02%2F16%2Fleetcode-SetMatrixZeroes%2F</url>
    <content type="text"><![CDATA[Set Matrix ZeroesGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.（设置矩阵整行&amp;列为0） Example: 1. 遍历矩阵，集合维护“0”的行列号123456789101112131415161718192021222324class Solution: def setZeroes(self, matrix: 'List[List[int]]') -&gt; 'None': """ Do not return anything, modify matrix in-place instead. """ m, n = len(matrix), len(matrix[0]) columns = set() rows = set() for i in range(m): for j in range(n): if matrix[i][j] == 0: columns.add(j) rows.add(i) for i in rows: # matrix[i] = [0]*n for j in range(n): matrix[i][j] = 0 for j in columns: for i in range(m): matrix[i][j] = 0]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Simplify Path]]></title>
    <url>%2F2019%2F02%2F16%2Fleetcode-SimplifyPath%2F</url>
    <content type="text"><![CDATA[Simplify PathGiven an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.（简化文件路径） Example: 1. 堆栈12345678910111213class Solution: def simplifyPath(self, path: 'str') -&gt; 'str': dirs = [x for x in path.split('/') if x and x != '.'] results = [] for dir in dirs: if dir == '..': results.pop() if results else None else: results.append(dir) return '/' + '/'.join(results)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Climbing Stairs]]></title>
    <url>%2F2019%2F02%2F16%2Fleetcode-ClimbingStairs%2F</url>
    <content type="text"><![CDATA[Climbing StairsYou are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? (Note: Given n will be a positive integer.)（爬楼梯问题） Example: 1. 动态规划12345678class Solution: def climbStairs(self, n: 'int') -&gt; 'int': dp = [1 for _ in range(n+1)] for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Sqrt X]]></title>
    <url>%2F2019%2F02%2F16%2Fleetcode-sqrtx%2F</url>
    <content type="text"><![CDATA[Sqrt(x)Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.（实现Sqrt(x)） Example: 1. 二分查找123456789101112class Solution: def mySqrt(self, x: 'int') -&gt; 'int': left, right = 0, x while left &lt;= right: middle = (left + right)//2 if middle * middle &lt;= x and (middle+1) * (middle+1) &gt; x: return middle elif middle * middle &lt; x: left = middle + 1 else: right = middle - 1]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>binary search</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_AddBinary]]></title>
    <url>%2F2019%2F01%2F24%2Fleetcode-AddBinary%2F</url>
    <content type="text"><![CDATA[Add BinaryGiven two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0.（二进制字符串加法） Example: 1. 十进制 &amp; 二进制转换12345678910class Solution: def addBinary(self, a, b): """ :type a: str :type b: str :rtype: str """ a = int(a, 2) b = int(b, 2) return "&#123;:b&#125;".format(a + b)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Plus One]]></title>
    <url>%2F2019%2F01%2F24%2Fleetcode-PlusOne%2F</url>
    <content type="text"><![CDATA[Plus OneGiven a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself.（数组形式的数字串数值加1） Example: 1. 加法进位原则Note: 需要特别注意第一个数字进位的情况。 12345678910111213141516171819202122class Solution: def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ n = len(digits) add = 1 result = [0 for _ in range(n+1)] for i in range(n-1, -1, -1): add += digits[i] result[i+1] = add % 10 add = add // 10 if add == 0: return result[1:] else: result[0] = add return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Valid Number]]></title>
    <url>%2F2019%2F01%2F15%2Fleetcode-ValidNumber%2F</url>
    <content type="text"><![CDATA[Valid NumberValidate if a given string can be interpreted as a decimal number.（字符串是否为有效数字） Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number: Numbers 0-9 Exponent - “e” Positive/negative sign - “+”/“-“ Decimal point - “.” Of course, the context of these characters also matters in the input. Example: 1. 有限状态机（Deterministic Finite Automaton, DFA）所谓“确定有穷状态”，必然需要我们自己动手构造出所有状态来，如下所示： 0 初始无输入或者只有space的状态1 输入了数字之后的状态2 前面无数字，只输入了dot的状态3 输入了+/-状态4 前面有数字和有dot的状态5 ‘e’ or ‘E’输入后的状态6 输入e之后输入+/-的状态7 输入e后输入数字的状态8 前面有有效数输入之后，输入space的状态 123456789101112131415161718192021222324252627282930313233343536class Solution: def isNumber(self, s): """ :type s: str :rtype: bool """ # 0invalid, 1space, 2sign, 3digit, 4dot, 5exponent, 6num_inputs INVALID, SPACE, SIGN, DIGIT, DOT, EXPONENT = 0, 1, 2, 3, 4, 5 transitionTable=[[-1, 0, 3, 1, 2, -1], #0 no input or just spaces [-1, 8, -1, 1, 4, 5], #1 input is digits [-1, -1, -1, 4, -1, -1], #2 no digits in front just Dot [-1, -1, -1, 1, 2, -1], #3 sign [-1, 8, -1, 4, -1, 5], #4 digits and dot in front [-1, -1, 6, 7, -1, -1], #5 input 'e' or 'E' [-1, -1, -1, 7, -1, -1], #6 after 'e' input sign [-1, 8, -1, 7, -1, -1], #7 after 'e' input digits [-1, 8, -1, -1, -1, -1]] #8 after valid input input space state = 0 for c in s: inputtype = INVALID if c == ' ': inputtype = SPACE elif c == '-' or c == '+': inputtype = SIGN elif c.isdigit(): inputtype = DIGIT elif c == '.': inputtype = DOT elif c.lower() == 'e': inputtype = EXPONENT state = transitionTable[state][inputtype] if state == -1: return False return state == 1 or state == 4 or state == 7 or state == 8 2. 正则表达式考察正则表达式的书写： 前后的空格 “(\s*)” 整个数字的符号 “[+-]?” 纯小数或者带小数 ((\.[0-9]+)|([0-9]+(\.[0-9]*)?))，这部分可以单独出现，也可以是科学计数法的前部分。 科学计数法，(e[+-]?[0-9]+)?（*表示匹配0至多次，+表示匹配1至多次，?表示匹配0至1次。） 1234567891011import re class Solution: def isNumber(self, s): """ :type s: str :rtype: bool """ pattern = "(\\s*)[+-]?((\\.[0-9]+)|([0-9]+(\\.[0-9]*)?))(e[+-]?[0-9]+)?(\\s*)" return bool(re.fullmatch(pattern, s)) 3. 搞笑版直接调用 python 的类型转换函数float()，出现异常则不是有效的数字。 123456789101112class Solution: def isNumber(self, s): """ :type s: str :rtype: bool """ try: float(s) except: return False return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Minimum Path Sum]]></title>
    <url>%2F2019%2F01%2F15%2Fleetcode-MinimumPathSum%2F</url>
    <content type="text"><![CDATA[Minimum Path SumGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time.（最小带权路径和，只能向右或者向下移动从左上角移动到右下角的带权路径和） Example: 1. 动态规划在前两道题目的基础上，类似于求一个带权路径和的问题。具体实现过程如下： 12345678910111213141516171819202122class Solution: def minPathSum(self, grid): """ :type grid: List[List[int]] :rtype: int """ m, n = len(grid), len(grid[0]) dp = [[0]*n for _ in range(m)] for i in range(m): for j in range(n): if i==0 and j==0: dp[i][j] = grid[i][j] elif i==0: dp[i][j] = dp[i][j-1] + grid[i][j] elif j==0: dp[i][j] = dp[i-1][j] + grid[i][j] else: dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j] return dp[m-1][n-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Unique Paths II]]></title>
    <url>%2F2019%2F01%2F15%2Fleetcode-UniquePathsII%2F</url>
    <content type="text"><![CDATA[Unique Paths IIA robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be?（不同的路径II，只能向右或者向下移动在有路障的情况下从左上角移动到右下角的路径个数） Example: 1. 动态规划写出其动规表达式 dp[i][j] = dp[i-1][j] + dp[i][j-1]。但是需要另外考虑： 遇到路障时，dp[i][j] = 0，继续扫描。 由于从左上角开始扫描，在扫描第一行时：dp[i][j] = dp[i][j-1]。 在扫描第一列时：dp[i][j] = dp[i-1][j] 。 具体实现形式如下： 1234567891011121314151617181920212223class Solution: def uniquePathsWithObstacles(self, obstacleGrid): """ :type obstacleGrid: List[List[int]] :rtype: int """ m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[1]*n for _ in range(m)] for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 continue if i == 0 and j &gt; 0: dp[i][j] = dp[i][j-1] elif j == 0 and i &gt; 0: dp[i][j] = dp[i-1][j] elif i &gt; 0 and j &gt; 0: dp[i][j] = dp[i][j-1] + dp[i-1][j] return dp[m-1][n-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Unique Paths]]></title>
    <url>%2F2019%2F01%2F15%2Fleetcode-UniquePaths%2F</url>
    <content type="text"><![CDATA[Unique PathsA robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there?（不同的路径，只能向右或者向下移动从左上角移动到右下角的路径个数） Example: 1. 动态规划写出其动规表达式 dp[i][j] = dp[i-1][j] + dp[i][j-1] 即可，具体实现形式如下： 1234567891011121314class Solution: def uniquePaths(self, m, n): """ :type m: int :type n: int :rtype: int """ dp = [[1]*n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Rotate List]]></title>
    <url>%2F2019%2F01%2F14%2Fleetcode-RotateList%2F</url>
    <content type="text"><![CDATA[Rotate ImageGiven a linked list, rotate the list to the right by k places, where k is non-negative.(k 次旋转链表) Example: 1. 旋转 k 次首先获得链表的长度，然后每一次旋转链表都将链表的链尾排到链首，如此循环 k 次。具体实现方法如下： 1234567891011121314151617181920212223242526272829303132333435363738# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def rotateRight(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if not (head and head.next) : return head cur = head length = 1 while cur.next: cur = cur.next length += 1 k = k % length new_head = ListNode(0) new_head.next = head while k &gt; 0: p_tail_before = new_head p_tail = new_head.next while p_tail.next != None: p_tail_before = p_tail_before.next p_tail = p_tail.next p_tail.next = new_head.next p_tail_before.next = None new_head.next = p_tail k -= 1 return new_head.next 2. 旋转 1 次在获取链表的长度的同时，将其转换成一个循环链表，计算出当前应该由谁作为链首，这样将链表分为两部分再重新拼接。具体实现方法如下： 12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def rotateRight(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if not (head and head.next) : return head cur = head length = 1 while cur.next: cur = cur.next length += 1 # Circular list cur.next = head k = k % length index = length - k p_head_before = cur p_head = head # get the new head of the list for i in range(index): p_head_before = p_head_before.next p_head = p_head.next p_head_before.next = None return p_head]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Permutation Sequence]]></title>
    <url>%2F2019%2F01%2F13%2Fleetcode-PermutationSequence%2F</url>
    <content type="text"><![CDATA[Permutation SequenceThe set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: “123”, “132”, “213”, “231”, “312”, “321”. Given n and k, return the k_th permutation sequence.(排列组合结果的第 K 项) Note: Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive. Example: 1. 找规律在n=4，k=9时， 最高位可以取{1, 2, 3, 4}，而每个数重复3!=6次。所以第 k=9 个排列的 s[0] 为{1, 2, 3, 4}中的第 9/6+1=2 个数字，即s[0]=2； 同样地，对于以 2 开头的6个数字而言，k=9是其中的第 k’=9%(3!)=3 个。而剩下的数字{1, 3, 4}的重复周期为 2!=2次。所以 s[1] 为{1, 3, 4} 中的第k’/(2!)+1=2个，即 s[1]=3； 以此类推，对于以 23 开头的2个数字而言，k=9是其中的第k’’=k’%(2!)=1 个。剩下的数字{1, 4}的重复周期为 1!=1次。所以 s[2]=1； 对于以 231 开头的一个数字而言，k=9是其中的第k’’’=k’’/(1!)+1=1 个。所以s[3]=4。 综上所述，按照顺序寻找 n 的全排列中的第 k 个，也是就是不断地对 (n-1)! 取商和余数的过程。这里使用 k-1 来判断是为了方便处理边界条件。具体实现方法如下： 123456789101112131415161718class Solution: def getPermutation(self, n, k): """ :type n: int :type k: int :rtype: str """ nums = [str(i) for i in range(1, n+1)] result = '' k -= 1 for i in range(n): rank, k = divmod(k, math.factorial(n-i-1)) result += nums[rank] # nums.remove(nums[rank]) nums.pop(rank) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>back tracking</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Spiral Matrix II]]></title>
    <url>%2F2019%2F01%2F13%2Fleetcode-SpiralMatrixII%2F</url>
    <content type="text"><![CDATA[Spiral Matrix IIGiven a positive integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order.（螺旋式生成矩阵） Example: 1. 方向模拟事先定义四个方向，按照题中的螺旋式的方向在遍历矩阵，过程中遇到边界时不断的修改方向并修改新的边界。具体实现过程如下：（与Spiral Matrix类似） 123456789101112131415161718192021222324252627282930313233343536373839class Solution: def generateMatrix(self, n): """ :type n: int :rtype: List[List[int]] """ if n == 0: return [] direct_map = &#123; 'right': [0, 1], 'down': [1, 0], 'left': [0, -1], 'up': [-1, 0] &#125; result = [[0]*n for _ in range(n)] left_border, right_border, up_border, down_border=0, n-1, 0, n-1 fill = 1 direction = 'right' i, j = 0, 0 while fill &lt;= n*n: result[i][j] = fill fill += 1 if direction=='right' and j==right_border: direction = 'down' up_border += 1 elif direction=='down' and i==down_border: direction='left' right_border -= 1 elif direction=='left' and j==left_border: direction='up' down_border -= 1 elif direction=='up' and i==up_border: direction='right' left_border += 1 i += direct_map[direction][0] j += direct_map[direction][1] return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Length of Last Word]]></title>
    <url>%2F2019%2F01%2F13%2Fleetcode-LengthofLastWord%2F</url>
    <content type="text"><![CDATA[Length of Last WordGiven a string s consists of upper/lower-case alphabets and empty space characters “ ”, return the length of last word in the string. If the last word does not exist, return 0.（字符串最后一个单词的长度） Note:A word is defined as a character sequence consists of non-space characters only. Example: 1. 字符串处理本题考查python中基本的字符串处理函数，比较简单。具体实现方法如下：（其中之所以需要使用 strip() 是因为当字符串为 “a ” 时，最后一个单词应该是 “a”） 1234567891011121314class Solution: def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ result = 0 words = s.strip().split(' ') if len(words) == 0: return 0 else: return len(words[-1])]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Insert Interval]]></title>
    <url>%2F2019%2F01%2F12%2Fleetcode-InsertInterval%2F</url>
    <content type="text"><![CDATA[Insert IntervalGiven a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times.（插入间隔区间） Example: 1. 遍历间隔区间直接遍历间隔区间数组，并在遇到交叉的情况下时不断更新新插入的间隔区间的起止位置。具体实现过程如下： 1234567891011121314151617181920212223242526272829303132333435# Definition for an interval.# class Interval:# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution: def insert(self, intervals, newInterval): """ :type intervals: List[Interval] :type newInterval: Interval :rtype: List[Interval] """ if len(intervals) == 0: return [newInterval] result = [] insert_new = False for interval in intervals: if interval.end &lt; newInterval.start: result.append(interval) elif interval.start &gt; newInterval.end: if not insert_new: result.append(newInterval) insert_new = True result.append(interval) else: newInterval = Interval(min(interval.start, newInterval.start), max(interval.end, newInterval.end)) if not insert_new: result.append(newInterval) return result 2. 合并间隔区间借用前一道题目的方法，把待插入的间隔区间和数组合并，然后合并交叉的区间。具体实现方法如下： 1234567891011121314151617181920212223242526272829# Definition for an interval.# class Interval:# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution: def insert(self, intervals, newInterval): """ :type intervals: List[Interval] :type newInterval: Interval :rtype: List[Interval] """ if len(intervals) == 0: return [newInterval] intervals.append(newInterval) intervals.sort(key = lambda x: x.start) result = [] for interval in intervals: if not result or interval.start &gt; result[-1].end: result.append(interval) else: result[-1].start = min(result[-1].start, interval.start) result[-1].end = max(result[-1].end, interval.end) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>array</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Merge Intervals]]></title>
    <url>%2F2019%2F01%2F10%2Fleetcode-MergeIntervals%2F</url>
    <content type="text"><![CDATA[Merge IntervalsGiven a collection of intervals, merge all overlapping intervals.(合并间隔区间) Example: 1. 贪心算法类似于教室安排问题，根据每个间隔区间的 start 排序，然后遍历所有的间隔区间： 当前间隔区间的 start 位置大于之前所有合并的区间的 end 时，加入新的间隔区间； 更新合并区间的 end 为之前合并区间的 end 和当前间隔区间 end 的最大值。 1234567891011121314151617class Solution: def merge(self, intervals): """ :type intervals: List[Interval] :rtype: List[Interval] """ intervals.sort(key=lambda x: x.start) result = [] for interval in intervals: if not result or result[-1].end &lt; interval.start: result.append(interval) else: result[-1].end = max(result[-1].end, interval.end) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Jump Game]]></title>
    <url>%2F2019%2F01%2F10%2Fleetcode-JumpGame%2F</url>
    <content type="text"><![CDATA[Jump GameGiven an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.(跳棋游戏，确定能否到达队尾) Example: 1. 贪心算法遍历数组，求得可到达的最远 index。若index &gt; n-1，则可以到达最后。具体实现方法如下： 1234567891011121314151617class Solution: def canJump(self, nums): """ :type nums: List[int] :rtype: bool """ max_index = 0 n = len(nums) if n &lt;= 1: return True for i in range(n-1): if max_index &gt;= i: max_index = max(max_index, i + nums[i]) if max_index &gt;= n-1: return True return False]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Spiral Matrix]]></title>
    <url>%2F2019%2F01%2F10%2Fleetcode-SpiralMatrix%2F</url>
    <content type="text"><![CDATA[Spiral MatrixGiven a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.（螺旋式遍历矩阵） Example: 1. 方向模拟事先定义四个方向，按照题中的螺旋式的方向在遍历矩阵，过程中遇到边界时不断的修改方向并修改新的边界。具体实现过程如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution: def spiralOrder(self, matrix): """ :type matrix: List[List[int]] :rtype: List[int] """ if not matrix: return [] m = len(matrix) n = len(matrix[0]) direction = &#123; 'right': [0, 1], 'down': [1, 0], 'left': [0, -1], 'up': [-1, 0] &#125; answer = [] i, j = 0, 0 direct = 'right' left_border, right_border, up_border, down_border = 0, n-1, 0, m-1 while len(answer) &lt; m * n: answer.append(matrix[i][j]) if i==up_border and j==right_border and direct=='right': direct = 'down' up_border += 1 elif i==down_border and j==right_border and direct=='down': direct = 'left' right_border -= 1 elif i==down_border and j==left_border and direct=='left': direct = 'up' down_border -= 1 elif i==up_border and j==left_border and direct=='up': direct = 'right' left_border += 1 i += direction[direct][0] j += direction[direct][1] return answer 2. zip函数在看别人的简单解法中发现用zip不断地旋转矩阵，每次都获得矩阵的第一行就是螺旋式遍历的结果。具体实现方法如下： 1234567891011class Solution: def spiralOrder(self, matrix): """ :type matrix: List[List[int]] :rtype: List[int] """ answer = [] while matrix: answer += matrix.pop(0) matrix = [*zip(*matrix)][::-1] return answer]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Maximum Subarray]]></title>
    <url>%2F2019%2F01%2F09%2Fleetcode-MaximumSubarray%2F</url>
    <content type="text"><![CDATA[Maximum SubarrayGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.(数组连续子串的和最大) Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Example: 1. 动态规划这个题目写出动规表达式就很容易得到具体的解法：dp[i+1] = max(dp[i]+nums[i+1], nums[i+1])。具体的解法如下： 12345678910111213class Solution: def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ n = len(nums) dp = [nums[0] for _ in range(n)] for i in range(1, n): dp[i] = max(dp[i-1] + nums[i], nums[i]) return max(dp) 2. 分治法题中要求使用分治法来解决这个问题，我们可以分 3 类情况来讨论。对于一个数组 nums 的 [left, right]子串，其中点为 mid = (left + right) // 2， 答案序列完全在[left, mid - 1]中； 答案序列完全在[mid + 1, right]中； 答案序列为包含 mid 的左右延续的序列。 12345678910111213141516171819202122232425262728293031323334353637class Solution: def divide(self, left, right): if (left &gt; right): return self.nums[0] # divide and conquer mid = (left + right) // 2 left_max = self.divide(left, mid-1) right_max = self.divide(mid+1, right) # situation 3 left part sum = 0 max_lsum = 0 for i in range(mid-1, left-1, -1): sum += self.nums[i] max_lsum = max(max_lsum, sum) # situation 3 right part sum = 0 max_rsum = 0 for i in range(mid+1, right+1): sum += self.nums[i] max_rsum = max(max_rsum, sum) max_sum = max(left_max, right_max) max_sum = max(max_sum, max_lsum + self.nums[mid] + max_rsum) return max_sum def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ self.nums = nums n = len(nums) return self.divide(0, n-1)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>dynamic programming</tag>
        <tag>divide and conquer</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_N-Queens II]]></title>
    <url>%2F2019%2F01%2F09%2Fleetcode-N-QueensII%2F</url>
    <content type="text"><![CDATA[N-Queens IIThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.(N皇后的问题，求解个数) Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively. Example: 1. 回溯法与前一题方法相同，只需将具体的解法保存。具体实现过程如下： 123456789101112131415161718192021222324252627282930313233import copyclass Solution: def check(self, matrix, _i, _j): for i in range(self.n): for j in range(self.n): if matrix[i][j] == 'Q': if j == _j or abs(_i - i) == abs(_j - j): return False return True def dfs(self, i, matrix): if (i == self.n): self.count += 1 else: for j in range(self.n): if self.check(matrix, i, j): matrix[i][j] = 'Q' self.dfs(i+1, matrix) matrix[i][j] = '.' def totalNQueens(self, n): """ :type n: int :rtype: List[List[str]] """ self.n = n self.count = 0 matrix = [['.' for _ in range(self.n)] for _ in range(self.n)] self.dfs(0, matrix) return self.count]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_N-Queens]]></title>
    <url>%2F2019%2F01%2F09%2Fleetcode-N-Queens%2F</url>
    <content type="text"><![CDATA[N-QueensThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.(N皇后的问题，求所有解) Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively. Example: 1. 回溯法类似于这种解空间可以用树表示，且存在某种约束条件的问题可以用回溯法求解。具体实现过程如下： 123456789101112131415161718192021222324252627282930313233343536import copyclass Solution: def check(self, matrix, _i, _j): for i in range(self.n): for j in range(self.n): if matrix[i][j] == 'Q': if j == _j or abs(_i - i) == abs(_j - j): return False return True def dfs(self, i, matrix): if (i == self.n): result = [] for row in matrix: result.append(''.join(row)) self.result.append(result) else: for j in range(self.n): if self.check(matrix, i, j): matrix[i][j] = 'Q' self.dfs(i+1, matrix) matrix[i][j] = '.' def solveNQueens(self, n): """ :type n: int :rtype: List[List[str]] """ self.n = n self.result = [] matrix = [['.' for _ in range(self.n)] for _ in range(self.n)] self.dfs(0, matrix) return self.result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Pow(x, n)]]></title>
    <url>%2F2019%2F01%2F09%2Fleetcode-Pow-x-n%2F</url>
    <content type="text"><![CDATA[Pow(x, n)Implement pow(x, n), which calculates x raised to the power n (x^n).(指数计算) Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range [−2^31, 2^31 − 1] Example: 1. 递归类似于二分法的方式进行指数运算。其中比较巧妙的地方是在 abs(n) 是奇数时，无论 n 是正数还是负数，left = n // 2 一定是比较小的哪一个，因此最终的结果一定是另外乘以 x。 123456789101112131415161718192021class Solution: def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1 if n == 1: return x if n == -1: return 1/x left = n // 2 re = self.myPow(x, left) if left * 2 == n: return re * re else: return re * re * x]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>hash table</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Group Anagrams]]></title>
    <url>%2F2019%2F01%2F09%2Fleetcode-GroupAnagrams%2F</url>
    <content type="text"><![CDATA[Group AnagramsGiven an array of strings, group anagrams together.(将使用相同字符构成的不同排列的单词合并) Note: All inputs will be in lowercase. The order of your output does not matter. Example: 1. 哈希表 / Dict遍历数组中的每一个单词，将每个单词根据所组成的字符排序从而得到哈希表的key。具体实现过程如下： 12345678910111213141516171819202122class Solution: def groupAnagrams(self, strs): """ :type strs: List[str] :rtype: List[List[str]] """ word_map = &#123;&#125; for word in strs: items = list(word) items.sort() items = ''.join(items) if items not in word_map: word_map[items] = [word] else: word_map[items].append(word) result = [] for key in word_map: result.append(word_map[key]) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>hash table</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Rotate Image]]></title>
    <url>%2F2019%2F01%2F09%2Fleetcode-RotateImage%2F</url>
    <content type="text"><![CDATA[Rotate ImageYou are given an nxn 2D matrix representing an image. Rotate the image by 90 degrees (clockwise).(顺时针旋转矩阵90度) Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example: 1. 矩阵转置 + 翻转行为了在不使用额外空间的情况下实现矩阵的顺时针旋转，可将其变化转变为矩阵的转置，然后对每一行进行翻转。具体实现过程如下： 1234567891011121314class Solution: def rotate(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ n = len(matrix) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for j in range(n//2): matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j] # matrix[i][:] = matrix[i][::-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Permutations II]]></title>
    <url>%2F2019%2F01%2F09%2Fleetcode-PermutationsII%2F</url>
    <content type="text"><![CDATA[Permutations IIGiven a collection of numbers that might contain duplicates, return all possible unique permutations.(含有重复元素的全排列) Example: 1. 递归按照我们平时求全排列的思路，在选取数组中的某个数时，计算剩下的数组的全排列，具体实现方法如下： 123456789101112131415161718192021222324class Solution: def permuteUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 1: return [nums] results = [] for i, item in enumerate(nums): new_nums = nums[0:i] + nums[i+1:] remain_results = self.permuteUnique(new_nums) if len(remain_results[0]) == 1: result = [item, remain_results[0][0]] if result not in results: results.append(result) else: for items in remain_results: result = [item] + [data for data in items] if result not in results: results.append(result) return results]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Permutations]]></title>
    <url>%2F2019%2F01%2F09%2Fleetcode-Permutations%2F</url>
    <content type="text"><![CDATA[PermutationsGiven a collection of distinct integers, return all possible permutations.(排列组合) Example: 1. 递归按照我们平时求全排列的思路，在选取数组中的某个数时，计算剩下的数组的全排列，具体实现方法如下： 12345678910111213141516171819class Solution: def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 1: return [nums] results = [] for item in nums: new_nums = [num for num in nums if num != item] result = self.permute(new_nums) if len(result[0]) == 1: results.append([item, result[0][0]]) else: for _list in result: results.append([item] + [data for data in _list]) return results 2. DFS另外一个思路是在看别人的解法发现的，使用深度优先搜索（DFS）的方法，具体实现方法如下： 1234567891011121314151617class Solution: def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ permutations = [] self.dfs(permutations, [], nums) return permutations def dfs(self, perms, perm_in_progress, nums): # If we're out of numbers to use, Perm_in_progress is finished if not nums: perms.append(perm_in_progress) for index in range(0, len(nums)): self.dfs(perms, perm_in_progress + [nums[index]], nums[:index] + nums[index+1:])]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Jump Game II]]></title>
    <url>%2F2019%2F01%2F09%2Fleetcode-JumpGameII%2F</url>
    <content type="text"><![CDATA[Jump Game IIGiven an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps.(跳棋游戏II，最小步到队尾) Note: You can assume that you can always reach the last index. Example: 1. 动态规划从后向前遍历数组，根据 i+1 ~ nums[i]+i 需要跳的步数来得到当前需要跳的最小步数。具体实现如下：Note: 特别需要注意的是在 nums 数组中为 0 的情况，需要单独考虑，否则上述的数组子集为空。 123456789101112131415161718class Solution: def jump(self, nums): """ :type nums: List[int] :rtype: int """ n = len(nums) jumps = [0 for _ in range(n)] for i in range(n-2, -1, -1): if nums[i] == 0: jumps[i] = n + 1 elif nums[i] + i &gt;= n-1: jumps[i] = jumps[n-1] + 1 else: jumps[i] = min(jumps[i+1: i + nums[i] + 1]) + 1 return jumps[0] 2. 贪心算法题目中说明了所有测试数据都有解，而且不需要知道具体的是如何到达最后一格的。可以通过贪心的思想从左向右遍历，每次都可获得到目前为止可以到达的最远的位置 curr_max_index；在遍历过程中，若当前的位置 i 超过了上一次跳动得到的最远的的位置 last_max_index ，则增加跳动的步数。具体实现过程如下： 1234567891011121314151617class Solution: def jump(self, nums): """ :type nums: List[int] :rtype: int """ step = 0 last_max_index = 0 curr_max_index = 0 for i in range(len(nums)): if (i &gt; last_max_index): step += 1 last_max_index = curr_max_index curr_max_index = max(curr_max_index, nums[i] + i) return step]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Wildcard Matching]]></title>
    <url>%2F2019%2F01%2F06%2Fleetcode-WildcardMatching%2F</url>
    <content type="text"><![CDATA[Wildcard MatchingGiven an input string (s) and a pattern (p), implement wildcard pattern matching with support for “?” and “*”.(通配符匹配) “?” Matches any single character.“*” Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like “?” or “*”. Example: 1. 动态规划这个题跟之前的字符串匹配类似，不同点在于之前 “*” 可以匹配的是零个至多个连续的字符，而这道题目中的 “*” 是可以匹配任意的字符串。我们还是可以基于动态规划的思想来解决这道题目，具体解法如下。其中在 pattern 中第 j 个元素为 “*” 时，分为两种情况： 当前 “*” 表示为空串，则 dp[i][j] = dp[i-1][j] 当前 “*” 匹配当前的第 i 个字符 s[i-1], 则 dp[i][j] = dp[i][j-1] 1234567891011121314151617181920class Solution: def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ len_s = len(s) len_p = len(p) dp = [[False] * (len_p + 1) for _ in range(len_s + 1)] dp[0][0] = True for i in range(len_s + 1): for j in range(1, len_p + 1): if p[j-1] == '*': dp[i][j] = dp[i][j-1] or dp[i-1][j] else: dp[i][j] = i&gt;=1 and dp[i-1][j-1] and (p[j-1] in &#123;s[i-1], '?'&#125;) return dp[len_s][len_p]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>dynamic programming</tag>
        <tag>back tracking</tag>
        <tag>string</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Multiply Strings]]></title>
    <url>%2F2019%2F01%2F03%2Fleetcode-MultiplyStrings%2F</url>
    <content type="text"><![CDATA[Multiply StringsGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.（用非库函数的方式返回两个字符串表示的整数的乘积） Example: Note: The length of both num1 and num2 is &lt; 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly. 实现库函数 atoi 和 itoa由于题中备注了不让使用自带的库函数，因此可以自己实现。其中在 python 中 ord()表示将字符转换为ASCII码，chr()表示将ASCII码转换为字符。具体实现过程如下： 12345678910111213141516171819202122232425class Solution: def multiply(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ def atoi(s): result = 0 for char in s: result = result * 10 + (ord(char) - ord('0')) return result def itoa(num): if num == 0: return "0" s = "" while num: char = num % 10 + ord('0') s = chr(char) + s num = num // 10 return s return itoa(atoi(num1) * atoi(num2))]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Trapping Rain Water]]></title>
    <url>%2F2018%2F12%2F26%2Fleetcode-TrappingRainWater%2F</url>
    <content type="text"><![CDATA[Trapping Rain WaterGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.（收集雨水） Example: 根据这个例子我们发现途中的蓝色的方块为6个，即最多蓄水位6。 两个指针蓄水实质上是找从左到右或者从右到左高度下降的地方：设定左右指针 left 和 right，max_left, max_right 分别记录从左到右和从右到左的最大值。 假设 max_left &lt;= max_right，这时我们从左边向右边看，蓄水值为 max_left - height[left]，更新左指针； 在 max_left &gt; max_right，这时我们从右边向左边看，蓄水值为 max_right - height[right]，更新右指针； 最终在 left 和 right 指针相遇时，退出循环，返回所有位置存储水的总量。具体实现过程如下： 12345678910111213141516171819202122232425class Solution: def trap(self, height): """ :type height: List[int] :rtype: int """ if not height: return 0 result = 0 max_left, max_right = 0, 0 left, right = 0, len(height)-1 while left &lt; right: max_left = max(height[left], max_left) max_right = max(height[right], max_right) if max_left &lt;= max_right: result += (max_left - height[left]) left += 1 else: result += (max_right - height[right]) right -= 1 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_First Missing Positive]]></title>
    <url>%2F2018%2F12%2F25%2Fleetcode-FirstMissingPositive%2F</url>
    <content type="text"><![CDATA[First Missing PositiveGiven an unsorted integer array, find the smallest missing positive integer.（在未排序数组中找到最小的非正数） Note: Your algorithm should run in O(n) time and uses constant extra space. Example: 1. 哈希法要在时间复杂度为 \( O(n)\)，且常数额外空间的情况下完成这个问题。哈希法的思路是分析数组中的正数应该在的位置。我们发现例子中的 [3, 4, -1, 1] 的答案是2，我们可以通过遍历数组将其转换为 [1, -1, 3, 4]，即数组中的index为 i 的值应该是正数 i + 1，从左向右遍历若不满足这个要求，则这就是我们要找的缺失的最小正数。 1234567891011121314151617181920212223class Solution: def firstMissingPositive(self, nums): """ :type nums: List[int] :rtype: int """ i, n = 0, len(nums) while i &lt; n: # nums[i] &gt; 0, nums[i] &lt;= n means positive number in [1, n] # nums[i] != i+1 means index==i but it is not i + 1 # nums[nums[i] - 1] != nums[i] means index==nums[i] - 1 which should be nums[i] if nums[i] &gt; 0 and nums[i] &lt;= n and nums[i] != i+1 and nums[nums[i] - 1] != nums[i]: temp = nums[i] nums[i], nums[temp-1] = nums[temp-1], nums[i] else: i += 1 for i in range(n): if nums[i] != i+1: return i+1 return n+1]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Combination Sum II]]></title>
    <url>%2F2018%2F12%2F25%2Fleetcode-CombinationSumII%2F</url>
    <content type="text"><![CDATA[Combination Sum IIGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination.（从集合中挑选和为特定值的数字组合，同一元素只可选一次） Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example: 1. 回溯法这道题与上一题的区别在于： 这个题限制了 candidates 中的元素只可以用一次。因此将遍历后的数组 candidates[i+1:] 继续遍历（因为candidates已经排序过了）。 candidates 可能存在有重复的元素。因此在生成最终的结果时，需要查重 list(re_set) not in self.result。 123456789101112131415161718192021222324252627class Solution: def backtracking(self, re_set, candidates, target): if target == 0 and list(re_set) not in self.result: self.result.append(list(re_set)) else: for i in range(len(candidates)): if target &lt; candidates[i]: break else: re_set.append(candidates[i]) self.backtracking(re_set, candidates[i+1:], target - candidates[i]) re_set.pop() def combinationSum2(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ self.result = [] re_set = [] candidates.sort() self.backtracking(re_set, candidates, target) return self.result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Combination Sum]]></title>
    <url>%2F2018%2F12%2F25%2Fleetcode-CombinationSum%2F</url>
    <content type="text"><![CDATA[Combination SumGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times.（从集合中挑选和为特定值的数字组合，同一元素可选多次） Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example: 1. 回溯法在构建回溯法的过程中，需要注意的是及时更新 target 来更新回溯限制条件。另外也可以事先对 candidates 排序来减少遍历的次数来节省时间。 1234567891011121314151617181920212223class Solution: def backtracking(self, re, candidates, target): if target == 0: self.result.append(list(re)) else: for i in range(len(candidates)): if target &lt; candidates[i]: continue re.append(candidates[i]) self.backtracking(re, candidates[i:], target - candidates[i]) re.pop() def combinationSum(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ self.result = [] self.backtracking([], candidates, target) return self.result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>back tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Count and Say]]></title>
    <url>%2F2018%2F12%2F24%2Fleetcode-CountandSay%2F</url>
    <content type="text"><![CDATA[Count and Say读字符串 这个题目 LeetCode 给的解释和实例 really 让人难以理解。简单来说是这样的： n = 1时，返回‘1’ n = 2时，由于 n-1 为1，且其对应的字符串为‘1’，读作 one 1， 则输出 ‘11’ n = 3时，由于 n-1 为2，且其对应的字符串为‘11’，读作 two 1， 则输出 ‘21’ n时，对n-1的对应的字符串读取的过程进行输出。 这很明显是一个递归的问题，先得到n-1对应的字符串，然后遍历字符串得到相应的读法并输出。具体实现过程如下： 1. 递归1234567891011121314151617181920212223242526class Solution: def countAndSay(self, n): """ :type n: int :rtype: str """ if n == 1: return '1' last_string = self.countAndSay(n-1) match_char = last_string[0] match_count = 0 result_string = '' for char in last_string: if char == match_char: match_count += 1 else: result_string += str(match_count) + match_char match_char = char match_count = 1 result_string += str(match_count) + match_char return result_string]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Sudoku Solver]]></title>
    <url>%2F2018%2F12%2F21%2Fleetcode-SudokuSolver%2F</url>
    <content type="text"><![CDATA[Sudoku SolverWrite a program to solve a Sudoku puzzle by filling the empty cells.（求解数独盘） A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character ‘.’. Note: The given board contain only digits 1-9 and the character ‘.’. You may assume that the given Sudoku puzzle will have a single unique solution. The given board size is always 9x9. Example: 1. 回溯法 Back Tracking求解数独、八皇后等等都是一个很经典的应用回溯法（深度优先搜索 + 剪枝）的例子。主要分为三个部分： 寻找下一层节点，此处为find_next_empty()。 判断限制条件，此处为check_constraint()。 针对找到的节点继续进行 DFS, 如果已经满足要求则返回True，否则继续判断并不满足要求则回溯，此处为back_track()。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution: # find the next entry need to fill def find_next_empty(self): for row in range(0, 9): for col in range(0, 9): if self.board[row][col] == '.': return [row, col] return False # check the constraint def check_constraint(self, x, y, num): # check row for data in self.board[x]: if data == num: return False # check col for data in list(zip(*self.board))[y]: if data == num: return False # check square square_row = x // 3 * 3 square_col = y // 3 * 3 datas = [] for i in range(3): datas += self.board[square_row + i][square_col: square_col + 3] for data in datas: if data == num: return False return True def back_track(self): entry = self.find_next_empty() if entry == False: return True else: [row, col] = entry # DFS for i in range(1, 10): check = self.check_constraint(row, col, str(i)) # pruning if check: self.board[row][col] = str(i) re = self.back_track() # back tracking if not re: self.board[row][col] = '.' else: return True return False def solveSudoku(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ self.board = board self.back_track()]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>back tracking</tag>
        <tag>hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Valid Sudoku]]></title>
    <url>%2F2018%2F12%2F21%2Fleetcode-ValidSudoku%2F</url>
    <content type="text"><![CDATA[Valid SudokuDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules.（数独盘有效性判断） Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character ‘.’. The given board size is always 9x9. Example: 1. 依次check根据题中设定的要求逐一排查，一旦检测到不符合标准的部分就返回 False。 1234567891011121314151617181920212223242526272829class Solution: def isListValid(self, list): clean = [i for i in list if i != '.'] s = set(clean) return len(s) == len(clean) def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ # row check for list in board: if self.isListValid(list) == False: return False # column check for list in zip(*board): if self.isListValid(list) == False: return False # square check for i in range(0, 9, 3): for j in range(0, 9, 3): list = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)] if self.isListValid(list) == False: return False return True 2. 使用Hash Map只需要遍历一次矩阵，在遍历过程中保存每个的数值的行、列的index，并保存数值属于9个正方形中的哪一个（i//3, j//3）。具体实现过程如下： 1234567891011121314151617181920212223class Solution: def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ dict = &#123;&#125; for i, row in enumerate(board): for j, ch in enumerate(row): if ch == '.': continue if ch in dict: result_index = dict[ch] for index in result_index: if index[0] == i or index[1] == j or index[2] == (i//3, j//3): return False dict[ch].append([i, j, (i//3, j//3)]) else: dict[ch] = [[i, j, (i//3, j//3)]] return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Search Insert Position]]></title>
    <url>%2F2018%2F12%2F21%2Fleetcode-SearchInsertPosition%2F</url>
    <content type="text"><![CDATA[Search Insert PositionGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.（在有序数组中检索） Example: 1. 二分查找123456789101112131415161718192021222324class Solution: def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ n = len(nums) if n == 0: return 0 left, right = 0, n-1 while left &lt;= right: middle = (left + right) // 2 if target == nums[middle]: return middle elif target &lt; nums[middle]: right = middle - 1 else: left = middle + 1 return left]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Find First and Last Position of Element in Sorted Array]]></title>
    <url>%2F2018%2F12%2F21%2Fleetcode-FindFirstandLastPositionofElementinSortedArray%2F</url>
    <content type="text"><![CDATA[Find First and Last Position of Element in Sorted ArrayGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. （在时间复杂度为O(log n)的前提下在有序数组中检索target的第一次及最后一次） Example: 1. 二分查找1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def searchRange(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ n = len(nums) if n == 0: return [-1, -1] re_left, re_right = -1, -1 # find the first index left, right = 0, n-1 while left &lt;= right: middle = (left + right) // 2 if target == nums[middle]: re_left = middle right = middle - 1 elif target &gt; nums[middle]: left = middle + 1 else: right = middle - 1 if nums[left] != target: return [-1, -1] # find the last index left, right = 0, n-1 while left &lt;= right: middle = (left + right) // 2 if target == nums[middle]: re_right = middle left = middle + 1 elif target &gt; nums[middle]: left = middle + 1 else: right = middle - 1 return [re_left, re_right]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Search in Rotated Sorted Array]]></title>
    <url>%2F2018%2F12%2F21%2Fleetcode-SearchinRotatedSortedArray%2F</url>
    <content type="text"><![CDATA[Search in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n).（在时间复杂度为O(log n)的前提下在经旋转的有序数组中检索） Example: 1. 二分查找定义首尾指针，在每次循环的过程中将 target 和 首尾指针的序列的中间值进行比较。其中在更新首尾指针的过程中需要讨论当前的[left, middle]数组是有序还是无序两种情况讨论。具体实现如下： 12345678910111213141516171819202122232425262728293031class Solution: def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if not nums: return -1 left = 0 right = len(nums)-1 while left &lt;= right: middle = (left + right) // 2 if target == nums[middle]: return middle if nums[left] &lt;= nums[middle]: if target &lt; nums[middle] and target &gt;= nums[left]: right = middle - 1 else: left = middle + 1 else: if target &gt; nums[middle] and target &lt;= nums[right]: left = middle + 1 else: right = middle - 1 return -1]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Longest Valid Parentheses]]></title>
    <url>%2F2018%2F12%2F21%2Fleetcode-LongestValidParentheses%2F</url>
    <content type="text"><![CDATA[Longest Valid ParenthesesGiven a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.（最长有效括号对） Example: 1.动态规划这是一个很直观的动态规划的题目，需要分两种情况讨论： 当前字符为 ‘)’ 且前一个字符为 ‘(‘ ，则动态规划公式可以为 dp[i] = dp[i-2] + 2 当前字符为 ‘)’ 且前一个字符为 ‘)’ ，则我们需要考虑 s[i-dp[i-1]-1]，即上一个没有匹配成功的字符为 ‘(‘ 时，此时也算匹配成功，dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2。 这里需要特别注意的是需要加上 dp[i-dp[i-1]-2]， 因为这也算是连续的匹配。具体实现过程如下： 123456789101112131415161718192021222324class Solution: def longestValidParentheses(self, s): """ :type s: str :rtype: int """ n = len(s) if n &lt;= 1: return 0 dp = [0 for _ in range(n)] for i in range(1, n): if s[i] == ')' and s[i-1] == '(': if i &gt;=2: dp[i] = dp[i-2] + 2 else: dp[i] = 2 if s[i] == ')' and s[i-1] == ')': if i-dp[i-1]-1 &gt;= 0 and s[i-dp[i-1]-1] == '(': dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2 return max(dp) 2.栈首先我们在栈顶 push 一个-1最为起始条件表示已经扫描的index，在遍历字符串的过程中，遇到 ‘(‘ 就 push 进去新的index，遇到 ‘)’ 就pop堆栈并分两种情况讨论： 此时堆栈为空，表示 ‘)’ 的个数大于 ‘(‘ ，因此我们可以把此时的 index push进去，表示重新开始； 此时堆栈不为空，表示前面有剩余，我们可以计算当前的 index 和栈顶的差表示最终匹配成功的个数。 1234567891011121314151617181920212223class Solution: def longestValidParentheses(self, s): """ :type s: str :rtype: int """ n = len(s) stack = [] stack.append(-1) max_re = 0 for i, ch in enumerate(s): if ch == '(': stack.append(i) else: stack.pop() if len(stack) == 0: stack.append(i) else: max_re = max(max_re, i - stack[-1]) return max_re]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>dynamic programming</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Next Permutation]]></title>
    <url>%2F2018%2F12%2F21%2Fleetcode-NextPermutation%2F</url>
    <content type="text"><![CDATA[Next PermutationImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory.（从小到大全排列的下一个） Example: 1. 后向遍历整体的思路就是从后向前遍历： 当遇到第一个数值大于其前面的数值，记录下这个数值，如 [1, 3, 5, 4, 2], 则此时的 i 为2。 将数组中从i到最后的部分倒序，即变为 [1, 3, 2, 4, 5]。 再次遍历从i到最后的部分，找到第一个大于 nums[i-1]（此处为3） 的值并交换即可，即为 [1, 4, 2, 3, 5]。 1234567891011121314151617181920212223242526272829class Solution: def nextPermutation(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ n = len(nums) if n == 0: return for i in range(n-1, -1, -1): if i == 0: nums.reverse() return if nums[i] &gt; nums[i-1]: break j, k = i, n-1 while j &lt; k: nums[j], nums[k] = nums[k], nums[j] j += 1 k -= 1 for j in range(i, n): if nums[j] &gt; nums[i-1]: nums[i-1], nums[j] = nums[j], nums[i-1] break return 2. 后向遍历另一种思路与上述一致，只是交换步骤2和步骤3的顺序。即先找到位置i，并同时找到后续数组中最小的值j，交换值后再倒序。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Substring with Concatenation of All Words]]></title>
    <url>%2F2018%2F12%2F18%2Fleetcode-SubstringwithConcatenationofAllWords%2F</url>
    <content type="text"><![CDATA[Substring with Concatenation of All WordsYou are given a string s, and a list of words words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.（找到字符串中所有的子串，其为字符串数组全排列形成） Example: 1. 定长取字符串子串这道题我们不应该想着将所有字符串数组中的字符串的排列组合，这将是一个 \(O(n!)\)算法；而应该从另一个角度出发，遍历字符串。 由于数组中的字符串的长度 sub_length 是一致的，组合后的字符串的总长 whole_length 也可以确定，因此我们遍历字符串时每次都取出长度为 whole_length 的子串，然后将其分为子串长度均为 sub_length 的子串集合，判断这个子串集合和题中的 words 是否一致，这里的判断就借用了dict / hash map 实现。 Note： 边界条件 s, words都为空时需要单独考虑，否则后面的计算没有意义。 边界条件 i。遍历字符串时应该让 i 取到 len(s) - whole_length + 1，若为 len(s) - whole_length 时， 最后一个 sub 将无法取到。 字符串切分为等长的字符子串：subs = re.findall(‘.{‘+str(sub_length)+’}’, sub) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import reclass Solution: def findSubstring(self, s, words): """ :type s: str :type words: List[str] :rtype: List[int] """ if len(words) == 0 or s == '': return [] dict = &#123;&#125; for word in words: if word in dict: dict[word] += 1 else: dict[word] = 1 sub_length = len(words[0]) whole_length = len(words) * sub_length result = [] for i in range(len(s) - whole_length + 1): sub = s[i:i + whole_length] subs = re.findall('.&#123;'+str(sub_length)+'&#125;', sub) d = &#123;&#125; flag = 1 for word in subs: if word not in dict: flag = 0 break if word in d: d[word] += 1 else: d[word] = 1 if flag == 1: for item in d: if d[item] != dict[item]: flag = 0 break if flag == 1: result.append(i) return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>hash table</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Divide Two Integers]]></title>
    <url>%2F2018%2F12%2F18%2Fleetcode-DivideTwoIntegers%2F</url>
    <content type="text"><![CDATA[Divide Two IntegersGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero.（非乘 除 取模 方法实现除法） Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows. Example: 1. 减法实现除法这个题目很直观的就是将被除数不断地减去除数得到最终的商，但是会存在 Time Limit Exceeded 的问题。 因此需要在过程中不断地加大除数来加快得到最终结果。其中存在溢出的情况为被除数为-2^31, 除数为-1，得到的商为2^31，因此需要单独考虑。具体实现如下： 123456789101112131415161718192021222324252627282930313233class Solution: def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if (dividend &lt; 0 and divisor &lt; 0) or (dividend &gt; 0 and divisor &gt; 0): flag = 1 else: flag = -1 dividend = abs(dividend) divisor = abs(divisor) re = 0 i = 1 new_divisor = divisor while dividend &gt;= new_divisor: re += i dividend -= new_divisor new_divisor += new_divisor i += i if dividend &lt; new_divisor: new_divisor = divisor i = 1 if flag &lt; 0: return -re else: MAX = pow(2, 31) - 1 return min(re, MAX)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>binary search</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Implement strStr()]]></title>
    <url>%2F2018%2F12%2F18%2Fleetcode-ImplementstrStr%2F</url>
    <content type="text"><![CDATA[Implement strStr()Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.（实现寻找字符串子串函数） Example: 1. 遍历 – easy123456789101112131415161718192021class Solution: def strStr(self, haystack, needle): """ :type haystack: str :type needle: str :rtype: int """ n = len(needle) m = len(haystack) if n == 0: return 0 if n &gt; m: return -1 for i in range(m-n+1): if haystack[i:i+n] == needle: return i return -1 2. 调用 python 库函数 in, index1234567891011class Solution: def strStr(self, haystack, needle): """ :type haystack: str :type needle: str :rtype: int """ if needle not in haystack: return -1 else: return haystack.index(needle)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Remove Element]]></title>
    <url>%2F2018%2F12%2F18%2Fleetcode-RemoveElement%2F</url>
    <content type="text"><![CDATA[Remove ElementGiven an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length.（删除数组中特定元素，限制空间复杂度） Example: 1. 特定元素个数这是一道 easy 题，需要在常量的空间复杂度的情况下去掉数组中特定的元素，与前一道题目的思想类似，只需要维护一个变量来记录在遍历过程中总共有 k 个值与 val 相等，并在探索到不是 val 的同时将其前第 k 个数值赋为与其相等。具体实现过程如下： 123456789101112131415class Solution: def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ k = 0 for i, item in enumerate(nums): if item == val: k += 1 else: nums[i-k] = item return len(nums)-k]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Remove Duplicates from Sorted Array]]></title>
    <url>%2F2018%2F12%2F18%2Fleetcode-RemoveDuplicatesfromSortedArray%2F</url>
    <content type="text"><![CDATA[Remove Duplicates from Sorted ArrayGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.（删除数组中重复的元素，限制空间复杂度） Example: 1. 重复元素个数这是一道easy题，需要在常量的空间复杂度的情况下去掉数组中重复的元素，只需要维护一个变量来记录在遍历过程中总共有多少个数字是重复的k，并在探索到新数据的同时将其前第k个数值赋为与其相等。具体实现过程如下： 1234567891011121314151617class Solution: def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ k = 0 now = None for i, item in enumerate(nums): if item != now: now = item if k != 0: nums[i-k] = item else: k += 1 return len(nums)-k]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Reverse Nodes in k-Group]]></title>
    <url>%2F2018%2F12%2F18%2Fleetcode-ReverseNodesink-Group%2F</url>
    <content type="text"><![CDATA[Reverse Nodes in k-GroupGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.（链表分组倒排） Note: Only constant extra memory is allowed. You may not alter the values in the list’s nodes, only nodes itself may be changed. Example: 1. 链表指针问题（头节点）遍历链表的过程中保存每 k 个的一组的头尾指针，将其翻转之后继续遍历。具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverse(self, p_prev_head, p_head, p_tail, k): p = p_head new_p = ListNode(0) new_p.next = p_tail.next while k != 0: k -= 1 tmp = p.next p.next = new_p.next new_p.next = p p = tmp p_prev_head.next = new_p.next def reverseKGroup(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if k == 1: return head new_head = ListNode(0) new_head.next = head p_prev_head = new_head p_head = head p_tail = head i = 1 while p_tail != None: if i == k: i = 1 self.reverse(p_prev_head, p_head, p_tail, k) p_prev_head = p_head p_head = p_prev_head.next p_tail = p_head else: i += 1 p_tail = p_tail.next return new_head.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Swap Nodes in Pairs]]></title>
    <url>%2F2018%2F12%2F13%2Fleetcode-SwapNodesinPairs%2F</url>
    <content type="text"><![CDATA[Swap Nodes in PairsGiven a linked list, swap every two adjacent nodes and return its head.（交换链表中相邻的两个值） Note: Your algorithm should use only constant extra space.You may not modify the values in the list’s nodes, only nodes itself may be changed. Example: 链表指针这个题是一个很直观的指针问题，在设计算法的过程中将指针的变换在纸上设计出来即可得出算法，具体实现过程如下：（引入头指针是一个链表中常用的方法） 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ newNode = ListNode(0) newNode.next = head p = newNode while p.next and p.next.next: q = p.next p.next = q.next q.next = p.next.next p.next.next = q p = q return newNode.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Merge k Sorted Lists]]></title>
    <url>%2F2018%2F12%2F11%2Fleetcode-MergekSortedLists%2F</url>
    <content type="text"><![CDATA[Merge k Sorted ListsMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.（合并k个有序链表） Example: 1. 分治法这个问题是一个典型的分治法解决的问题。其时间复杂度为 \(O(mlog(n))\)，其中 \(n\) 为序列个数，\(m\) 为所有序列的长度和。具体实现过程如下： 12345678910111213141516171819202122232425262728293031323334353637class Solution: def merge2Lists(self, left, right): head = ListNode(0) p = left q = right tail = head while p != None and q != None: if p.val &lt; q.val: tail.next = p p = p.next else: tail.next = q q = q.next tail = tail.next if p != None: tail.next = p else: tail.next = q return head.next def mergeKLists(self, lists): """ :type lists: List[ListNode] :rtype: ListNode """ n = len(lists) if n == 0: return [] if n == 1: return lists[0] left_list = self.mergeKLists(lists[:n//2]) right_list = self.mergeKLists(lists[n//2:]) return self.merge2Lists(left_list, right_list) 2. 堆排序另外一种方式是遍历所有的链表，并用堆保存并排序，然后根据堆构建最终的链表。其时间复杂度为 \(O(mlog(n))\)，其中 \(n\) 为序列个数，\(m\) 为所有序列的长度和。具体实现过程如下： 123456789101112131415161718192021222324from heapq import heappush, heappopclass Solution: def mergeKLists(self, lists): """ :type lists: List[ListNode] :rtype: ListNode """ if lists == []: return [] heap = [] for list in lists: while list: heappush(heap, list.val) list = list.next head = ListNode(0) tail = head while heap: tail.next = ListNode(heappop(heap)) tail = tail.next return head.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>divide and conquer</tag>
        <tag>heap</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Generate Parentheses]]></title>
    <url>%2F2018%2F12%2F07%2Fleetcode-GenerateParentheses%2F</url>
    <content type="text"><![CDATA[Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.（n 对括号所有组合形式） Example:For example, given n = 3, a solution set is: 1. 递归 &amp; 深度优先搜索这个题目是一个很直观的括号对序列的问题，问题的实质就是在每次添加新的括号时： 任何位置的之前的 NUM_( &gt;= NUM_)。 12345678910111213141516171819class Solution: def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ result = [] def generateParenthesis(left_remain, right_remain, s): if left_remain == 0 and right_remain == 0: result.append(s) if left_remain &gt; 0: generateParenthesis(left_remain-1, right_remain, s + '(') if right_remain &gt; 0 and left_remain &lt; right_remain: generateParenthesis(left_remain, right_remain-1, s + ')') generateParenthesis(n, n, '') return result 2. 动态规划经过观察发现如下： n==0, result = [‘’] n==1, result = [ () = ( + result_0 + ) + result_0] n==2, result = [()() = ( + result_0 + ) + result_1()(()) = ( + result_1() + ) + result_0] n==3, result = [()()() = ( + result_0 + ) + result_2_1()()()(()) = ( + result_0 + ) + result_2_2(())(())() = ( + result_1() + ) + result_1()(()()) = ( + result_2_1()() + ) + result_0((())) = ( + result_2_2(()) + ) + result_0]因此我们可以得出如下结论： dp[n] = [( + x + ) + y for x in dp[j] for y in dp[i - j - 1]] , j in range(i)。 1234567891011121314class Solution: def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ dp = [[] for i in range(n+1)] dp[0].append('') for i in range(n + 1): for j in range(i): dp[i] += ['(' + x + ')' + y for x in dp[j] for y in dp[i - j - 1]] return dp[n]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>back tracking</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Merge Two Sorted Lists]]></title>
    <url>%2F2018%2F12%2F06%2Fleetcode-MergeTwoSortedLists%2F</url>
    <content type="text"><![CDATA[Merge Two Sorted ListsMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.（合并有序链表） Example: 1. 三个链表指针链表合并问题，三个指针分别指向当先的l1，当前的l2 以及合并后的链表的尾指针，然后遍历两个链表，具体的实现过程如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if l1 == None: return l2 if l2 == None: return l1 if l1.val &lt;= l2.val: target = l1 p = l1.next q = l2 else: target = l2 p = l1 q = l2.next tail = target while p != None and q != None: if p.val &lt;= q.val: tail.next = p tail = p p = p.next else: tail.next = q tail = q q = q.next if p != None: tail.next = p else: tail.next = q return target 2. 增加头结点在上述的方法中，需要单独判断最终的头结点来自 l1 还是 l2，因此可以为目标链表设定一个头结点，则可以省去此步骤的判断。具体的实现过程如下： 123456789101112131415161718192021222324class Solution: def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l1 or not l2: return l1 or l2 tail = target = ListNode(0) while l1 and l2: if l1.val &lt;= l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next tail.next = l1 or l2 return target.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Valid Parentheses]]></title>
    <url>%2F2018%2F12%2F06%2Fleetcode-ValidParentheses%2F</url>
    <content type="text"><![CDATA[Valid ParenthesesGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.（判断有效的括号对） An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example: 1. 栈匹配括号的匹配问题是一个很直观的栈的应用问题。具体实现过程如下： 12345678910111213141516171819class Solution: def isValid(self, s): """ :type s: str :rtype: bool """ stack = [] mapping = &#123;')': '(', ']': '[', '&#125;': '&#123;'&#125; for ch in s: if ch in mapping: top = stack.pop() if stack else '#' if top != mapping[ch]: return False else: stack.append(ch) return not stack 2. 栈匹配后来看别人的解答过程中有一种更直观简单的栈匹配过程。具体实现过程如下： 1234567891011121314151617class Solution: def isValid(self, s): """ :type s: str :rtype: bool """ stack = [] for c in s: if c == '[': stack.append(']') elif c == '&#123;': stack.append('&#125;') elif c == '(': stack.append(')') elif not stack or c != stack.pop(): return False return not stack]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode_Remove Nth Node From End of List]]></title>
    <url>%2F2018%2F12%2F06%2Fleetcode-RemoveNthNodeFromEndofList%2F</url>
    <content type="text"><![CDATA[Remove Nth Node From End of ListGiven a linked list, remove the n-th node from the end of list and return its head.（删除链表尾开始的第 N 个） Example: 1. 正向定位这个是一个简单的链表增删的问题。从后往前删除，我们可以先通过遍历一次确定链表的长度，从而可以正向的定位到需要删除的位置。 12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ p = head length = 0 while p != None: p = p.next length += 1 if n &gt; length: return head elif n == length: return head.next else: p = head k = length - n - 1 while k != 0: k -= 1 p = p.next p.next = p.next.next return head]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>two pointers</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_4SumII]]></title>
    <url>%2F2018%2F12%2F06%2Fleetcode-4SumII%2F</url>
    <content type="text"><![CDATA[4SumIIGiven four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.（寻找4个数组中四个数的和为0的组合个数） Example: 1. 两次双重循环将其转换为两次双重循环的问题，第一次查找数组 A 和数组 B 中两个数的和保存在 Dict。第二次查找数组 C 和数组 D 中两个数的和的相反数书否在 Dict中。其时间复杂度为 \(O(n^2)\)。12345678910111213141516171819202122232425262728class Solution: def fourSumCount(self, A, B, C, D): """ :type A: List[int] :type B: List[int] :type C: List[int] :type D: List[int] :rtype: int """ n = len(A) dict = &#123;&#125; for i in range(n): for j in range(n): sum = A[i] + B[j] if sum not in dict: dict[sum] = 1 else: dict[sum] += 1 result = 0 for i in range(n): for j in range(n): sum = C[i] + D[j] if -sum in dict: result += dict[-sum] return result 1. 两次双重循环2将上述过程中的解法中的通过 index索引改为 python中的 in 遍历。12345678910111213141516171819202122232425class Solution: def fourSumCount(self, A, B, C, D): """ :type A: List[int] :type B: List[int] :type C: List[int] :type D: List[int] :rtype: int """ dict = &#123;&#125; for a in A: for b in B: if a + b not in dict: dict[a + b] = 1 else: dict[a + b] += 1 result = 0 for c in C: for d in D: if -c-d in dict: result += dict[-c-d] return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>hash table</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_4Sum]]></title>
    <url>%2F2018%2F12%2F04%2Fleetcode-4Sum%2F</url>
    <content type="text"><![CDATA[4SumGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.（寻找数组中四个数的和为target的组合） Example: 1. 四个指针可以将这个题理解为与之前的 3Sum 类似，但是这里要有三重循环，其时间复杂度为 \(O(n^3)\)。12345678910111213141516171819202122232425262728293031class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ result = [] n = len(nums) if n &lt; 4: return result nums.sort() for i in range(n): for j in range(i-2): k = j + 1 l = i - 1 while k &lt; l: sum = nums[i] + nums[k] + nums[l] + nums[j] if sum == target: if [nums[j], nums[k], nums[l], nums[i]] not in result: result.append([nums[j], nums[k], nums[l], nums[i]]) k+=1 l-=1 elif sum &gt; target: l-=1 else: k+=1 return result 2. 两次 2Sum + Dict换一种思路，以空间换时间。我们可以将其转换为两次 2Sum 的过程。第一次 2Sum 遍历数组中所有的两个数的和，并将索引在 dict 中保存。第二次 2Sum 来判断数组中的和与 Dict 是否满足要求 Target。其时间复杂度为 \(O(n^2)\)。123456789101112131415161718192021222324252627282930313233class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ result = [] n = len(nums) if n &lt; 4: return result nums.sort() dict = &#123;&#125; for i in range(n): for j in range(i): sum = nums[i] + nums[j] if sum not in dict: dict[sum] = [[j, i]] else: dict[sum].append([j, i]) for i in range(n): for j in range(i): sum = target - nums[i] - nums[j] if sum in dict: for list in dict[sum]: if list[0] &gt; i and [nums[j],nums[i], nums[list[0]], nums[list[1]]] not in result: result.append([nums[j],nums[i],nums[list[0]],nums[list[1]]]) return result 3. 递归 N-sum这个是在提交之后看到的别人的解法，将 N-sum 的问题递归的向下传递为 N-1, N-2 等等的问题，最终归结为 2Sum 的问题。 1234567891011121314151617181920212223242526272829303132class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ def findNsum(l, r, target, N, result, results): if r-l+1&lt;N or N&lt;2 or nums[l]*N &gt; target or nums[r]*N &lt; target: return if N == 2: while l &lt; r: sum = nums[l] + nums[r] if sum == target: results.append(result + [nums[l], nums[r]]) l += 1 while l &lt; r and nums[l] == nums[l-1]: l+=1 elif sum &lt; target: l += 1 else: r -= 1 else: for i in range(l, r+1): if i == l or (i &gt; l and nums[i-1] != nums[i]): findNsum(i+1, r, target-nums[i], N-1, result+[nums[i]], results) nums.sort() results = [] findNsum(0, len(nums)-1, target, 4, [], results) return results]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Letter Combinations of a Phone Number]]></title>
    <url>%2F2018%2F11%2F30%2Fleetcode-LetterCombinationsofaPhoneNumber%2F</url>
    <content type="text"><![CDATA[Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.（根据九宫格键盘将数字映射到字符） Example: 1. map / hash_table 进行索引这个问题很直观就是建立一个map进行索引。在提交过程中，发现如果考虑了digits == &#39;&#39;的情况，时间大幅度降低。说明在这种测试情况下，多考虑一些极端情况，直接返回结果，会使得整体的测试时间减少很多。 12345678910111213141516171819202122232425262728293031class Solution: def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ dict = &#123; '2': ['a', 'b', 'c'], '3': ['d', 'e', 'f'], '4': ['g', 'h', 'i'], '5': ['j', 'k', 'l'], '6': ['m', 'n', 'o'], '7': ['p', 'q', 'r', 's'], '8': ['t', 'u', 'v'], '9': ['w', 'x', 'y', 'z'] &#125; result = [] for ch in digits: letter = dict[ch] if len(result) == 0: result = letter else: new_result = [] for a in result: for b in letter: new_result.append(a + b) result = new_result return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>back tracking</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_3Sum Closest]]></title>
    <url>%2F2018%2F11%2F29%2Fleetcode-3SumClosest%2F</url>
    <content type="text"><![CDATA[3Sum ClosestGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.（寻找数组中三个数的和最接近target的一个组合） Example: 1. 三个指针排序后三个指针遍历数组。其时间复杂度为 \(O(n^2)\)。123456789101112131415161718192021222324252627class Solution: def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ nums.sort() n = len(nums) result = nums[0] + nums[1] + nums[2] for i in range(n - 2): l = i + 1 r = n - 1 while l &lt; r: threesum = nums[l] + nums[r] + nums[i] if threesum == target : return threesum if abs(threesum - target) &lt; abs(result - target): result = threesum if threesum &gt; target: r -= 1 else: l += 1 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_3Sum]]></title>
    <url>%2F2018%2F11%2F29%2Fleetcode-3Sum%2F</url>
    <content type="text"><![CDATA[3SumGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.（寻找数组中三个数的和为0的所有组合） Note:The solution set must not contain duplicate triplets. Example: 1. 三个指针最外层一个指针 i 遍历整个数组，在里层遍历过程中设置 [l, r] 区间，其中l , r = i + 1, len(nums) - 1,，这样三个数分别是nums[i]，nums[l] 和 nums[r]。这道题一定要记住去重，去重的方法如下，其时间复杂度为 \(O(n^2)\)。 i 去重： if i &gt; 0 and nums[i] == nums[i-1]: continue l 去重： while l &lt; r and nums[l] == nums[l-1]: l += 1 r 去重： while l &lt; r and nums[r] == nums[r+1]: r -= 1 12345678910111213141516171819202122class Solution(object): def threeSum(self, nums): result = [] nums.sort() if len(nums) &lt; 3: return result for i in range(len(nums) - 2): if i &gt; 0 and nums[i] == nums[i-1]: continue l, r = i + 1, len(nums) - 1 while l &lt; r : s = nums[i] + nums[l] + nums[r] if s == 0: result.append([nums[i] ,nums[l] ,nums[r]]) l += 1; r -= 1 while l &lt; r and nums[l] == nums[l - 1]: l += 1 while l &lt; r and nums[r] == nums[r + 1]: r -= 1 elif s &lt; 0 : l += 1 else: r -= 1 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Longest Common Prefix]]></title>
    <url>%2F2018%2F11%2F29%2Fleetcode-LongestCommonPrefix%2F</url>
    <content type="text"><![CDATA[Longest Common PrefixWrite a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”.（寻找最长公共前缀序列） Example: 1. 二分查找将数组二分，分别查找其最长公共前缀序列，然后查找结果的最长公共前缀序列。具体实现过程如下：1234567891011121314151617181920212223242526272829class Solution: def commonPrefixof2(self, str1, str2): result = "" n = min(len(str1), len(str2)) for i in range(n): if str1[i] == str2[i]: result += str2[i] else: break return result def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ result = '' n = len(strs) if n == 0: return "" elif n == 1: return strs[0] elif n == 2: return self.commonPrefixof2(strs[0], strs[1]) else: result1 = self.longestCommonPrefix(strs[:n//2]) result2 = self.longestCommonPrefix(strs[n//2:]) return self.commonPrefixof2(result1, result2) 2. Zip函数 &amp; Setzip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。具体实现过程如下：1234567891011121314class Solution: def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if not strs: return "" for i, word in enumerate(zip(*strs)): if len(set(word)) &gt; 1: return strs[0][:i] return min(strs) 3. 字符子串组成Set12345678910111213141516171819class Solution: def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ n = len(strs) if n == 0: return "" elif n == 1: return strs[0] length = min([len(s) for s in strs]) while length &gt; 0: substrings = [s[:length] for s in strs] if len(set(substrings)) == 1: return substrings[0] length -= 1 return ""]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Roman to Integer]]></title>
    <url>%2F2018%2F11%2F29%2Fleetcode-RomantoInteger%2F</url>
    <content type="text"><![CDATA[Roman to IntegerRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M for 1, 5, 10, 50, 100, 500 and 1000.（罗马字符转整数） Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example: 1. 遍历字符串_1遍历整个字符串，其中优先考虑两个字符表示的数值。其时间复杂度为 \(O(n)\)，具体实现过程如下：12345678910111213141516171819202122232425262728293031323334class Solution: def romanToInt(self, s): """ :type s: str :rtype: int """ base = &#123; 'M': 1000, 'CM': 900, 'D': 500, 'CD': 400, 'C': 100, 'XC': 90, 'L': 50, 'XL': 40, 'X': 10, 'IX': 9, 'V': 5, 'IV': 4, 'I': 1 &#125; result = 0 n = len(s) i = 0 while i &lt; n: if i &lt; n-1 and s[i:i+2] in base: result += base[s[i:i+2]] i += 2 elif s[i] in base: result += base[s[i]] i += 1 return result 2. 遍历字符串_2直接遍历整个字符串，但是在扫描过程中若出现后面的字符对应的字符大于前面的字符，则减去两倍的前面的字符表示的数值。其时间复杂度为 \(O(n)\)，具体实现过程如下： 12345678910111213141516171819202122232425class Solution: def romanToInt(self, s): """ :type s: str :rtype: int """ base = &#123; 'M':1000, 'D':500, 'C':100, 'L':50, 'X':10, 'V':5, 'I':1 &#125; temp = 0 result = 0 for ch in s: if base[ch] &gt; temp: result -= 2 * temp temp = base[ch] result += temp return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Integer to Roman]]></title>
    <url>%2F2018%2F11%2F28%2Fleetcode-IntegertoRoman%2F</url>
    <content type="text"><![CDATA[Integer to RomanRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M for 1, 5, 10, 50, 100, 500 and 1000.（整数转罗马字符） Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example: 1. 基数扩展由于 “4” 和 “9” 的特殊性，我们可以将其也包含在基数列表中，于是基数可以是1，4，5，9，10，40，50，90，100，400，500，900。具体实现过程如下：1234567891011121314151617181920212223242526272829303132class Solution: def intToRoman(self, num): """ :type num: int :rtype: str """ base = &#123; 1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I' &#125; base_list = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] result = "" for i in range(len(base_list)): if num // base_list[i] != 0: for j in range(num // base_list[i]): result += base[base_list[i]] num = num % base_list[i] return result 2. 列表索引列出所有可能的罗马字符的表示形式，然后直接对列表进行索引即可。具体实现过程如下：123456789101112class Solution: def intToRoman(self, num): """ :type num: int :rtype: str """ M = ["", "M", "MM", "MMM"] C = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"] X = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"] I = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"] return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Container With Most Water]]></title>
    <url>%2F2018%2F11%2F28%2Fleetcode-ContainerWithMostWater%2F</url>
    <content type="text"><![CDATA[Container With Most WaterGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2.（求最大矩形面积） Example: 1. 暴力轮循双层循环遍历得到所有可能的矩形的面积。很显然，该算法会 Time Limit Exceeded。其时间复杂度为 \(O(n^2)\)。具体实现过程如下： 1234567891011121314class Solution: def maxArea(self, height): """ :type height: List[int] :rtype: int """ area = 0 n = len(height) for j in range(n): for i in range(j): height_min = min(height[i], height[j]) area = max(area, height_min*(j-i)) return area 2. 头尾指针在数组的收尾分别维护一个指针，过程中将高度较低的指针向中间移动。其时间复杂度为 \(O(n)\)。具体实现过程如下： 123456789101112131415161718class Solution: def maxArea(self, height): """ :type height: List[int] :rtype: int """ area = 0 p_left = 0 p_right = len(height) - 1 while p_left &lt; p_right: area = max(area, min(height[p_left], height[p_right]) * (p_right - p_left)) if height[p_left] &lt; height[p_right]: p_left += 1 else: p_right -= 1 return area]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Regular Expression Matching]]></title>
    <url>%2F2018%2F11%2F26%2Fleetcode-RegularExpressionMatching%2F</url>
    <content type="text"><![CDATA[Regular Expression MatchingGiven an input string (s) and a pattern (p), implement regular expression matching with support for . and *, . matches any single character, * matches zero or more of the preceding element. The matching should cover the entire input string (not partial).（字符串正则表达式匹配） Note:s could be empty and contains only lowercase letters a-z.p could be empty and contains only lowercase letters a-z, and characters like . or *. Example: 1. 递归算法正则表达式的匹配算法可以很自然的想到递归，但是其时间复杂度比较高。 len(p) &gt;= 2 and p[1] = *，则需要分类讨论： p[0] 匹配了0个，则可以直接判断 s 和 p[2:] ； p[0] 至少匹配了1个，则可以判断 s[1:] 和 p ； len(p) &lt; 2，可以直接判断； 12345678910111213141516class Solution: def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ if not p: return not s first_match = bool(s) and (p[0] in &#123;s[0], '.'&#125;) if len(p) &gt;=2 and p[1] == '*': return (self.isMatch(s, p[2:])) or (first_match and self.isMatch(s[1:], p)) else: return first_match and self.isMatch(s[1:], p[1:]) 2. 动态规划dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配，具体 dp 迭代更新与上述相同。其中 j &gt;= 2 and dp[i][j-2] 表示不扩展当前的 * ，即认为此次匹配了0个。 i &gt;= 1 and j &gt;= 2 and dp[i-1][j] and p[j-2] in {s[i-1], &#39;.&#39;} 表示扩展当前的 * ，即认为此次匹配了1个。 1234567891011121314151617181920class Solution: def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ len_s = len(s) len_p = len(p) dp = [[False] * (len_p + 1) for _ in range(len_s + 1)] dp[0][0] = True for i in range(len_s + 1): for j in range(1, len_p + 1): if p[j-1] == '*': dp[i][j] = (i &gt;= 1 and j &gt;= 2 and dp[i-1][j] and p[j-2] in &#123;s[i-1], '.'&#125;) or (j &gt;= 2 and dp[i][j-2]) else: dp[i][j] = (i &gt;= 1 and dp[i-1][j-1] and p[j-1] in &#123;s[i-1], '.'&#125;) return dp[len_s][len_p]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>dynamic programming</tag>
        <tag>back tracking</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Palindrome Number]]></title>
    <url>%2F2018%2F11%2F26%2Fleetcode-PalindromeNumber%2F</url>
    <content type="text"><![CDATA[Palindrome NumberDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.（判断数字是否是回文序列） Example: 字符串翻转123456789class Solution: def isPalindrome(self, x): """ :type x: int :rtype: bool """ string = str(x) return string == string[::-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_String to Integer]]></title>
    <url>%2F2018%2F11%2F26%2Fleetcode-StringtoInteger%2F</url>
    <content type="text"><![CDATA[String to Integer (atoi)Implement atoi which converts a string to an integer.（字符串转32位整形） Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \([−2^{31}, 2^{31} − 1]\). For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Example: 字符串过滤-正则表达式首先删除字符串首尾的空格，通过正则表达式过滤剩下以 “+-0123456789” 开头的句子，提取剩下的字符串首部的数字串，再将其转换为整形。（注意需要将超出范围的部分返回0。） 12345678910111213141516171819202122232425262728293031323334import reclass Solution: def myAtoi(self, str): """ :type str: str :rtype: int """ string = str.strip() if not re.match(r'^(\-|\+)?\d+', string): return 0 INT_MIN = -pow(2, 31) INT_MAX = pow(2, 31) - 1 char_string = '+-0123456789' num_string = '' for i, char in enumerate(string): if char not in char_string: break if i != 0 and (char == '+' or char == '-'): break num_string += char if num_string[0] == '-': result = int(num_string[1:]) result = max(result * - 1, INT_MIN) return result elif num_string[0] == '+': result = int(num_string[1:]) else: result = int(num_string) result = min(result, INT_MAX) return result 注：需要考虑 \(+/- \) 出现在数字字符串中间的部分，因此 ‘0-1’ 需要通过if i != 0 and (char == &#39;+&#39; or char == &#39;-&#39;)过滤掉。当然，也可以直接通过match的group()函数，其返回值为匹配的字符串，进而获取开始的数值字符串。 1num_string = re.match(r'^(\-|\+)?\d+', string).group()]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>math</tag>
        <tag>regular expression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Reverse Integer]]></title>
    <url>%2F2018%2F11%2F26%2Fleetcode-ReverseInteger%2F</url>
    <content type="text"><![CDATA[Reverse IntegerGiven a 32-bit signed integer, reverse digits of an integer.（翻转一个有符号整形数值字符串） Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: \([−2^{31}, 2^{31} − 1]\). For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Example: 1. 字符串翻转1234567891011121314151617181920class Solution: def reverse(self, x): """ :type x: int :rtype: int """ string = str(x) n = len(string) if string[0] == '-': result = [string[n-i] for i in range(1, n)] result = ['-'] + result else: result = [string[n-i-1] for i in range(n)] re = int("".join(result)) if re &gt; pow(2, 31) - 1 or re &lt; - pow(2, 31): re = 0 return re 注：超过有符号整形的范围时需要返回0。另外string[::-1]也可以直接实现字符串的翻转。 2. 整形翻转12345678910111213141516171819202122class Solution: def reverse(self, x): """ :type x: int :rtype: int """ abso_x = abs(x) result = 0 while abso_x != 0 : a = abso_x % 10 abso_x = abso_x // 10 result = result * 10 + a if x &lt; 0: result *= -1 if result &gt; (pow(2, 31) - 1) or result &lt; -pow(2, 31): return 0 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Zig Zag Conversion]]></title>
    <url>%2F2018%2F11%2F26%2Fleetcode-ZigZagConversion%2F</url>
    <content type="text"><![CDATA[ZigZag ConversionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this:123P A H NA P L S I I GY I R And then read line by line: “PAHNAPLSIIGYIR”.（字符串ZIGZAG之后按行输出） Example: 规律根据ZigZag的规律，当行数为 numRows 时： ZigZag的第 i 行字符的序号为 \(k * (2 * numRows - 2) + i \) ； ZigZag的非第一行和最后一行的第 i 行的偶数个字符的序号是 \((k + 1) * (2 * numRows - 2) - i \)；其时间复杂度为 \(O(n)\)，具体实现过程如下：123456789101112131415161718192021class Solution: def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ if numRows == 1: return s result = "" n = len(s) add = 2 * numRows - 2 for i in range(numRows): for j in range(0, n-i, add): result += s[i+j] if (i != 0 and i != numRows-1 and j+add-i&lt;n): result += s[j+add-i] return result 注：这里需要特别注意的是保证 \(add = 2 * numRows - 2\) 的有效性，因此需要单独考虑 numRows 为1时的情况。 变步长遍历字符串这是一个十分巧妙的思路，仅仅只需要遍历一次字符串。题目的本质可以理解为将字符串分成 numRows 组，然后再连接起来。但是在遍历字符串时，需要根据 ZigZag 的形式来回的遍历，但实质也只遍历了一次。其时间复杂度为 \(O(n)\)，具体实现过程如下：12345678910111213141516171819202122232425class Solution: def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ n = len(s) if numRows == 1 or numRows &gt;= n: return s group_list = [""] * numRows index = 0 step = 1 for char in s: group_list[index] += char if index == 0: step = 1 elif index == numRows - 1: step = -1 index += step return "".join(group_list)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Longest Palindromic Substring]]></title>
    <url>%2F2018%2F11%2F26%2Fleetcode-LongestPalindromicSubstring%2F</url>
    <content type="text"><![CDATA[Longest Palindromic SubstringGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.（寻找最长回文序列） Example: 1.动态规划这也是一道很典型的动态规划的题目。简单地来看可以有如下规律： \[ if s[i] == s[j]\ and\ dp[i+1][j-1] == 1,\ dp[i][j] = 1\] 然后我们可以找到满足dp[i][j] == 1的最长的序列。其时间复杂度为 \(O(n^2)\)，空间复杂度为 \(O(n^2)\)。具体实现过程如下：12345678910111213141516171819202122232425class Solution: def longestPalindrome(self, s): """ :type s: str :rtype: str """ n = len(s) dp = [[0] * n for i in range(n)] result = '' max_len = 0 for i in range(n): dp[i][i] = 1 result = s[i] max_len = 1 for j in range(n): for i in range(0, j): if s[i] == s[j] and (dp[i+1][j-1] == 1 or i == j-1): dp[i][j] = 1 if max_len &lt;= j - i + 1: result = s[i:j+1] max_len = j - i + 1 return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Median of Two Sorted Arrays]]></title>
    <url>%2F2018%2F11%2F23%2Fleetcode-MedianofTwoSortedArrays%2F</url>
    <content type="text"><![CDATA[Median of Two Sorted ArraysThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty.（两个有序数组的中位数） Example: 1. 分治法_1我们可以将中位数简单的理解成将数组分成两个部分，一部分中的数值总是大于另一部分。因此，我们可以看做是找\((m+n)\)个数中的第\((m+n)/2\)数值的大小（需要单独考虑\((m+n)\)的奇偶性）。其时间复杂度为 \(O(log(m+n))\)。具体实现过程如下：1234567891011121314151617181920212223242526272829303132333435class Solution: def findKth(self, nums1, nums2, k): if not nums1: return nums2[k] if not nums2: return nums1[k] len1 = len(nums1) len2 = len(nums2) i, j = len1 // 2, len2 // 2 if i + j &lt; k: if nums1[i] &gt; nums2[j]: return self.findKth(nums1, nums2[j+1:], k-j-1) else: return self.findKth(nums1[i+1: ], nums2, k-i-1) else: if nums1[i] &gt; nums2[j]: return self.findKth(nums1[:i], nums2, k) else: return self.findKth(nums1, nums2[:j], k) def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ length = len(nums1) + len(nums2) if length % 2: return self.findKth(nums1, nums2, length//2) else: return (self.findKth(nums1, nums2, length//2) + self.findKth(nums1, nums2, length//2-1))/2 2. 分治法_2与上面的思路相同，但是不同的是找第 \(k\) 个值时，并不是直接将两个数组混合一起找第 \(k\) 个，而是以比较短的数组 A 为基准，找到符合条件的 \(i\)，使得 \(A[i]\) 和 \(B[k-i]\) 刚好满足其中一个是第\(k\)个数。其时间复杂度为 \(O(log(min(m, n)))\)。具体实现过程如下：12345678910111213141516171819def findKth(self, nums1, nums2, k): len1 = len(nums1) len2 = len(nums2) if len1 &gt; len2: len1, len2, nums1, nums2 = len2, len1, nums2, nums1 if not nums1: return nums2[k] if k == len1 + len2 - 1: return max(nums1[-1], nums2[-1]) i = len1 // 2 j = k - i if nums1[i] &gt; nums2[j]: # Assume it is O(1) to get A[:i] and B[j:]. In python, it's not but in cpp it is. return self.findKth(nums1[:i], nums2[j:], i) else: return self.findKth(nums1[i:], nums2[:j], j) 3. Sort()函数12345678910111213class Solution: def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ num = sorted(nums1 + nums2) l = len(num) if l%2 == 0: return((num[l//2] + num[l//2-1])/2) if l%2 != 0: return(num[l//2])]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hard</tag>
        <tag>array</tag>
        <tag>divide and conquer</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F11%2F23%2Fleetcode-LongestSubstringWithoutRepeatingCharacters%2F</url>
    <content type="text"><![CDATA[Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters.（字符串中的最大不重复子串） Example: 1. 暴力循环对字符串进行两轮循环，并在循环的过程中判断两个指针之间的字符串是否包含了重复的字符。其时间复杂度为 \(O(n^3)\)。在测试过程中会 Time Limit Exceeded。 2. 移动窗口 / 动态规划这道题是字符串中的很典型的 DP 问题。构建两个指针i和j，当指针j+1所指的元素在[i, j]中没有出现时，这时的字符串为[i, j+1]；当指针j+1所指的元素在[i, j]中有出现时，这时的字符串为[i+1, j]。另外，构建了一个字典来快速判断元素是否在子串中出现。其时间复杂度为 \(O(2n)\)。具体实现过程如下： 1234567891011121314151617181920class Solution: def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ d = &#123;&#125; long = 0 i = 0 j = 0 while(i &lt; len(s) and j &lt; len(s)): if (s[j] not in d) or (d[s[j]] == 0): d[s[j]] = 1 j += 1 long = max(long, j-i) else: d[s[i]] = 0 i += 1 return long 上面那个方法需要对整个字符串遍历两次，另外一种思路就是在字典dict中保存的是字符最后一次出现的下一个元素。指针j来遍历整个字符串，指针i来维护[0, j]中所有字符中最后一次出现的下一个元素，于是[i, j]就是最大不重复子串。其时间复杂度为 \(O(n)\)。具体实现过程如下： 12345678910111213141516171819class Solution: def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ d = &#123;&#125; i = 0 j = 0 long = 0 while j &lt; len(s) : if s[j] in d and d[s[j]] &gt; i: i = d[s[j]] else: long = max(long, j - i + 1) d[s[j]] = j + 1 j += 1 return long 注： 测试的时候考虑字符串为空等临界条件。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>hash table</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Add Two Numbers]]></title>
    <url>%2F2018%2F11%2F23%2Fleetcode-addtwonumbers%2F</url>
    <content type="text"><![CDATA[Add Two NumbersYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.（字符串/链表数值加法） Example: 这道题是一个很典型的字符串 String 变数字 Number 例子，不过这里使用了链表的概念来表示组成数值的每个数字。 1. 转换为数值计算很直观的，我们可以将每一个链表转化为一个真实的数值，计算两者的和之后再将其转换为链表。其时间复杂度为 \(O(m + n)\)。 123456789101112131415161718192021222324252627282930313233class Solution: def list2num(self, l): result = 0 j = 0 while l != None: num = 10 ** j * l.val result += num l = l.next j += 1 return result def num2list(self, num): if num == 0: return ListNode(0) l = ListNode(0) p = l while num != 0: a = num % 10 num = num // 10 new_l = ListNode(a) p.next = new_l p = p.next return l.next def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ left = self.list2num(l1) right = self.list2num(l2) return self.num2list(left + right) 2. 加法器我们可以将其看做一个加法器的过程，链表的从头到尾也就是加法器的从个位到最高位的过程，其中需要考虑到每一步加法计算的进位。其时间复杂度为 \(O(max(m + n))\)。 1234567891011121314151617181920212223242526272829class Solution: def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ l = None l3 = None a = 0 while l1 or l2 or a: if l1: a += l1.val l1 = l1.next if l2: a +=l2.val l2 = l2.next if l3: l3.next = ListNode(a % 10) l3 = l3.next else: l3 = ListNode(a % 10) l = l3 a = a // 10 return l 注：“/”“//”在python中的作用不同。“/”表示浮点数除法，结果为浮点数；“//”结果为整除向下取整。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>linked list</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_Two Sum]]></title>
    <url>%2F2018%2F11%2F23%2Fleetcode-twosum%2F</url>
    <content type="text"><![CDATA[Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.（一个数组中某两个元素的和为给定值） Example: 这道题是开始刷LeetCode的第一道题，难度属于esay，主要考察的是数组，另外也考虑到了哈希表。具体解法如下： 1. 暴力循环这种解法就是很直观，就是对数组进行两层循环遍历。其时间复杂度为 \(O(n^2)\), 空间复杂度为 \(O(1)\)。 2. 构建哈希表构建哈希表可以有效的降低时间复杂度，且只需要对数组遍历一次。其时间复杂度为 \(O(n)\), 空间复杂度为 \(O(n)\)。 (注：可以对数组进行两次遍历，第一次构建哈希表，第二次找答案。) 123456789101112class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ d = &#123;&#125; for i, number in enumerate(nums): if (target - number) in d: return [i, d[target-number]] d[number] = i 注：在思考的过程中需要认真看清题中的每个元素只能用一次，但是并不代表每个数值只能用一次。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Task-Oriented Dialog System]]></title>
    <url>%2F2018%2F11%2F15%2Ftask-oriented-dialog-systems%2F</url>
    <content type="text"><![CDATA[面向任务的对话（Task-oriented Dialog）主要关注在某些特定的领域，用户带有目的的发起的会话。本文将从一个具体的数据集出发，结合基于此数据集设计的不同的系统来具体的分析对于此类任务的the-State-of-Art。 数据集 In-Car DataSet数据集 In-Car DataSet，是用户和车载助手对于日程安排，天气和导航三个领域进行的多轮对话，下面是一个对话例子： 这个数据集中总共有3031次对话，具体信息如下： 其中针对3个不同的领域，日程安排，天气和导航，具有不同的槽类型以及槽值： 特别地，此数据中认为后台已经有一个知识库（Knowledge Base）。即用户提出请求后，系统会在这个知识库中找到匹配的答案，最终生成相应的答案。下面是两个基于此数据集的对话系统。 Key Value Retrieval Networks [1]这个模型是针对此数据集提出的 baseline，将End-to-End模型与信息检索模型结合。 Encoder - LSTM输入：历史对话，\((u_1, s_1, …, s_{i-1}, u_i)\)Hidden State: \(h_i\) Decoder输入：\(h_i\)Hidden State: \(\tilde{h_{t}}\)输出：\(y_1, y_2, …, y_n\)其中，在decoder的过程中，结合了Attention机制，来给知识库中不同的KB entry给予不同的权重。 Attention在知识库（Knowledege）中，每个entry表示为（subject, relation, objective）。在模型中，将每个entry表示为subject和relation的embedding的和\(k_j\)。具体的attention计算过程如下：\[u_i^t = w^T tanh(W_2 tanh(W_1[h_i, \tilde{h_{t}}]))\] \[a_i^t = softmax(u_i^t)\]\[\tilde{h_{t}}^{,} = a_i^t h_i\]\[u_j^t = r^T tanh(W_2 tanh(W_1[k_j, \tilde{h_{t}}]))\]\[o_t = U[\tilde{h_{t}}, \tilde{h_{t}}^{,}] + \tilde{v_{t}}\]\[y_t = Softmax(o_t)\]其中，\(\tilde{v_t}\)维度为|V| + n，|V|为词典长度，n表示为指知识库中entry的个数。需要特别注意的是，本文通过NER将知识库中具体的“槽值”替换为“槽类型”（如，“5pm”替换为“meeting_time”），这样就使得词典的长度大大减少。\(\tilde{v_t}\)中与知识库中相关的表示为\(u_j^t\)，其与为0，即加重网络在知识库上的权重。总的来说，我们可以将\(v_t\)看做是分别在原始词典和知识库上的概率分布，通过两者来确定最终的输出。最终的实验结果如下: Mem2Seq [2]这篇文章主要结合End-to-End memory network和Pointer network的思想。其中MemNN是将memory和question进行embedding，然后计算两者的匹配度；接着对memory进行另一种embedding之后，以匹配度作为权重得到输出；再结合question，通过softmax得到最终的answer。而Pointer network没有关注在输出，而是通过计算encoder和decoder的匹配度之后，直接根据其softmax值指向输入的某个部分，从输入序列里“提取”一些元素来输出。 Encoder - Multi-hop MemNN输入：U = [B; X]，其中X = {x1, …, xn, \$} 为对话历史，包括时间信息和用户信息（如“hello”表示为“hello t1 \$u”），\$表示结束；B = {b1, …, bl}表示知识库。输出：\(o_k\) \[ p_k^i = Softmax(q_k)^T C_i^k\] \[o_k = \sum p_k C_{k+1}\] \[q_{k+1} = q_k + o_k\] 一般的MemNN过程，其中\(C_i\)为Encoder的memory。 Decoder - GRU + MemNN输入：\(o_k\)HiddenState：\(h_t\)输出：\(P_{vocab}(\hat{y_t}), P_{ptr}\) \[P_{vocab}(\hat{y_t}) = Softmax(W_1[h_t; o^1])\] \[P_{ptr} = p_t^K \] 其中，\(P_{vocab}(\hat{y_t})\)结合第一个hop的输出得到输出词在词典上的分布，\(P_{ptr}\)是Decoder中MemNN的最后一个hop的\(p_t^K\)表示（此处K=3），可以看做是在对话历史和知识库上的分布。当生成的词为“\$”时，则从词典中选择词语作为输出，否则则在对话历史或者知识库中选择词作为输出。最终的实验结果如下: 下面是一个具体的生成案例： &nbsp;&nbsp;&nbsp;&nbsp; [1] Key-Value Retrieval Networks for Task-Oriented Dialogue.[2] Mem2Seq: Effectively Incorporating Knowledge Bases into End-to-End Task-Oriented Dialog Systems.]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>intent</tag>
        <tag>slot</tag>
        <tag>task-oriented</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Review on Intent Classification and Slot Filling]]></title>
    <url>%2F2018%2F11%2F02%2Fintent_slot%2F</url>
    <content type="text"><![CDATA[自然语言理解（Natural Language Understanding, NLU）是NLP领域的一个分支，在自然语言理解的过程中，首先就是对意图（Intent）分类，然后接着对槽位（Slot）填充。 意图分类时一个典型的文本分类的问题，常用的方法如下： 基于规则的方法用户人工定义一些匹配规则进行分类。 机器学习的方法SVM, Decision Tree等等。 深度学习的方法目前更加推崇使用 End-to-End 的网络进行分类。 最近收集了一些关于意图分类以及槽填充的相关的数据集以及对应的测试指标。 中文数据集NLPCC 2018 Task4 - Spoken Language Understanding in Task-Oriented Dialogue Systems数据描述 [1]这个数据集来源于某车载产品的真实日志数据，主要涉及音乐，导航以及打电话等等领域，11种意图以及15种槽值类型。其中包括 5.8K 次会话，总共有 26K 次叙述（Utterance）。特别地，这个数据集仅仅包含了用户的输入（没有系统的回复），并且针对错误的槽值进行了修正，如将“什话”修正为“神话”。 训练集：4705次会话, 21352次叙述。 验证集：1177次会话, 5350次叙述。 （训练集：验证集 约 4:1） 数据格式1234session ID 用户query 意图 语义槽标注 1 打电话 phone_call.make_a_phone_call 打电话 1 我想听美观 music.play 我想听&lt;song&gt;美观&lt;/song&gt; 1 我想听什话 music.play 我想听&lt;song&gt;什话||神话&lt;/song&gt; 评估方法这个比赛主要有两个评估方法: 意图分类，评估方法为F1值，具体的计算方法如下： 意图分类以及槽填充，评估方法是准确度。即意图分类以及所有的槽位都完全正确。 主要算法总共有16个队伍参加了这个比赛，但是只有两个队伍开源了他们的方法，分别是HLSTM-SLU模型和Sogou团队的模型。具体结果如下： HLSTM-SLU [2]这个可以看做是深度学习的方法和传统的机器学习方法相结合。模型结构如下： 这个模型主要由三个LSTM组成，两个双向LSTM处理输入和输出，一个单向LSTM处理一个会话中的多个叙述。 输入Bi-LSTM输入：Character Embedding + POS + Domain其中POS表示对每个字进行词性标注，并用类似于BI的方法进行编码；Domain表示不同领域的词，也用BI的方法进行编码，具体实例如下： Session LSTM输入：一次对话中的每轮的描述经过输入Bi-LSTM的输出经过最大池化之后的结果。输出：意图的类别 输出Bi-LSTM输入：Session LSTM + 输入Bi-LSTM输出：槽位标注 注：并没有直接使用LSTM的结果作为最终的结果，而是根据 CRF 预测最优的序列。 Trick: 使用 over sampling 解决意图类别中的样本不均衡的问题，并在过程中使用规则识别了一部分小样本的意图。 结果：这个模型在两个评估方法的结果最终为94.19%，90.84%。 Sogou [3]这个模型没有使用深度学习的方法，而是使用传统的机器学习中的序列标注方法。首先，他们认为用户的query可以根据是否有显性的意图词分为两类（这一部分主要根据实体词匹配算法得到）。对于有显性意图词语的query，采用基于规则的处理的方法进行标注；剩下的部分采用基于模型的方法，具体的模型方法分为5步： 对query进行分词和词性标注（POS）。 寻找槽边界：先对处理后的query使用character embedding + word embedding; 根据BILOU原则，使用CRF对其进行序列标注。 槽分类：根据槽边界检测结果的character embedding + word embedding以及词性标注结果POS，通过逻辑回归的方式（Logistic Regression）进行分类。 槽修正：若槽类别预测错误，则根据词之间的相似性寻找真实槽类别中的所有的值与之进行相似度比较，进而修正结果。 意图分类：使用XGBoost的方法，根据word embedding，query长度，槽类别进行意图分类。 注：由于训练样本比较少，针对模型预测错误的数据，他们根据比较query与Sogou语音中最匹配的进行替换，最终针对意图分类增加了500个数据，槽填充增加了1000个数据。 结果：这个模型在两个评估方法的结果最终为96.11%，94.49%。 英文数据集Frame数据描述 [4]这个数据集主要针对航班和酒店预订，来源于基于Wizard-of-Oz(WOz)设定的人机对话的过程（实际上是一个人假扮机器）。其中包括 1369 个对话, 总共有 19986 轮。 数据格式每一次叙述都包含 ‘author’, ‘text’, ‘labels’, ‘timestamp’, ‘frames’(‘frame id’, ‘frame parent id’, ‘requests, binary questions, compare requests’, ‘info’), ‘db’字段。其中 ‘labels’记录当前的active_frame以及对话过程中的Act(包括act名称以及对应的slot类型和值)， ‘info’字段主要为了标注对于槽位值是否为否定的。 Act类型：inform, offer, request, switch frame, suggest, no result, thankyou, goodbye….. 评估方法微软在提出这个数据集的同时，也定义了一个任务Frame Tracking，这个任务与State Tracking不同的是，它可以同时追踪一个frame与之前几轮相关的frame，以及由一个frame转变到多个frame，例如用户要求系统可以推荐4个符合条件的旅行，如下图所示： 这个任务就是需要预测是否有新的frame生成。如果有，则预测其目的Act，限制条件Ref Labels以及之前相关的Frame ID，如果预测结果完全匹配，则认为预测正确，最后计算准确度。同时计算总的预测有新的frame生成的叙述个数，计算其识别新frame生成的准确度。 主要算法Baseline [4]由下图可知模型结构，针对叙述中的每个词，将其表示为trigrams的形式，然后通过一个embedding层，tanh激活层。针对Act分类和Slot分类，分别用一个双向的GRU实现，输入为每个词在激活层的输出。最后经由一个softmax分类层得到最终的类别。 结果：这个模型在两个评估方法的结果最终为：frame识别准确度0.24 ± 0.02, frame新建识别准确度为0.49 ± 0.03。 Frame Tracking Model for Memory-Enhanced Dialogue Systems [5]微软的团队随后提出了一个新的模型来处理这个问题。 输入预处理 Token Encoding：每个词用trigrams的形式表示。如：“hello” -&gt; #he, hel, ell, llo, lo#。构建trigrams词典D-T，每个词都表示为（Trigrams ID）。 用户叙述：将叙述中的每个词用trigrams的形式表示，这些trigrams经过一个embedding层，输出的向量的和来表示这个token，再经过一个 Bidirectional GRU，将所有的隐层状态堆叠起来来表示此轮的叙述。 Frame：每个frame由槽类型Slot和槽值Value组成，与trigrams类似，分别构建槽类型词典D-S和槽值词典D-V。即，每个frame表示为（Slot ID, Token ID）。 Act：每个act由行动类型Act，槽类型Slot和槽值Value组成。即，每个act表示为（Act ID, Slot ID, Token ID）。 模型输入 当前轮之前所有的frames （Slot ID, Trigrams ID） 叙述 （Trigrams ID） 当前轮对应的行动Act （Act ID, Slot ID, Trigrams ID） 模型结构 对于frames，（Slot, Token）经过一个GRU，将隐层其映射为一个256维的向量，所有的隐层堆叠起来表示最终的frames，\(m_f\) （|F| * 256）；对于act，将（Act, Slot, Token）输入一个 Bidirectional GRU，将隐层以及叙述embedding连接起来，并将其映射为 \(m_{asv}\) （N * 256, N为act的数量）来表示acts； 通过计算 \(m_f\) 和 \(m_{asv}\) 的点乘的结果 \(S_m\) （N * |F|）来表示act和frame之间的相似性，也可以看做基于frame的一个多项分布。特别地，他们还事先根据act中的槽值与frame之间的槽值的相似性计算了act与frame之间的相似性 \(S_L\) 。最终，根据两者的线性组合来表示act与frame之间的相似性 S。 在用户新输入一个（act, slot, value）表示时，根据这个相似矩阵可以得到一个多项分布\(p_{asv, f}\) ，从而得到与之相关的frames，从而也就得到了他们实验的衡量指标之一，基于槽分类slot的frame追踪。 另外，对于每一个（act，frame）对，他们会根据输入的act, 以及用户的叙述经过两个全连接层得到最终的 \(p_{a, f}\) ，从而也就得到了他们实验的另一个衡量指标，基于行动act的frame追踪。 注：这里没有详细介绍实验的一些完善trick，如模型图中的\(g_c\)， \(g_n\)， \(h_d\)， \(h_c\)，详情请看论文。 结果：这个模型在基于槽分类的准确度为76.43 ± 4.49，基于行动Act分类的准确度为95.66 ± 2.34。 DSTC (Dialog State Tracking Challenge) [6, 7]数据描述DSTC 是针对一系列的对话数据，完成对话跟踪的任务。也就是针对每一个数据集，意在可以根据之前的状态来预测新的对话的状态。目前DSTC数据已经更新到DSCT6，下面将简单介绍各个版本的数据。 DSTC 1这个数据集包括城市BUS的预定电话中的对话数据。12963轮训练数据，2485轮测试数据。 DSTC 2&amp;3在DSTC 1的基础上，增加了关于餐厅，旅游信息等等相关的对话。其中DSTC2包括2218轮训练数据，1117轮测试数据；DSTC3包括3235轮训练数据，2275轮测试数据。数据中的semantics字段会对对话中的槽slot和目的act标注。下面是一个数据样例： 1234567DSTC2 and DSTC3 (Training Set)SYS: Which part of town?USR: The north uh areaSYS: Which part of town?USR: A cheap place in the northSYS: Clown cafe is a cheap restaurant in the north part of town. USR: Do you have any others like that?SYS: Galleria is another cheap restaurant in the north. USR: What is their phone number and address? DSTC 4这个数据集是人与人之间关于旅游信息的对话数据，其中有一个子任务Spoken language understanding，意在给每个叙述中的目的acts和语义槽slots打标签。挑战赛总共收到了5个提交模型[7]，其中最好的结果的F1值约为0.52。其中三个模型分别为： SVM分类模型输入：叙述的unigrams, bigrams, trigrams，标签（标注当前叙述与上一个叙述是否为同一个人） 逻辑回归模型输入：同上。 随机森林模型输入：问题数目，标签（标注当前叙述与上一个叙述是否为同一个人），标签（标注当前叙述与上上一个叙述是否为同一个人），标签（标注这个人是导游还是旅客） DSTC 5这个数据集针对跨语言测量，也就是训练集为英语数据，测试集为中文数据。 DSTC 6这个数据集关注在多轮对话，其任务包括端到端的目标导向的对话学习，端到端会话建模，以及对话故障检测。 评估方法 （DSTC2 &amp; 3） 准确度：正确预测的轮数占数据总轮数的百分数。 L2距离：向量1为正确预测的轮标为1，其余为0组成的向量；向量2为根据模型得到的每一个的概率值组成的向量，计算向量之间的距离。 主要算法这里我们主要关注在DSTC3上的四个模型。 马尔科夫判别模型 [8] 这是来自中科院声学与语言理解研究所的一个模型。为了能够支持未知的领域，因此这篇文章将通过假设每一轮的可能的域来动态的更新分类的类别。$$ Y_t^s = Y_{t-1}^s + H_t^s$$，其中\(H_t^s\)是在t轮对于槽类型s的假设的集合。 另外，也是本文中比较新的一点是马尔科夫判别模型，也就是将生成模型和判别模型相结合： 生成模型： \(P(S_t) = k \sum_{S_{t-1} \in S} P(O^t | S_t) P(S_t | S_{t-1}) P(S_t) \) 判别模型： \(P(S_t | O_1^t) = f(O_1^t)\) 马尔科夫判别模型：\((P(S_t | O_1^t) = \sum_{S_{t-1} \in S} P(S_t | O_1^t, S_{t-1}) P( S_{t-1} | O_1^{t-1})\) 在训练过程中，由于当前叙述之前所有的标签都是已知的，而预测过程中之前的都是预测的结果，这会导致训练的模型会过度依赖状态转移矩阵，这个问题称作标签过耦合问题。为了解决这个问题，他们设计了一个2步训练法： 第一步：训练一个传统的判别模型。 第二部：在第一步的基础上训练状态转移特征。 这样第一步预测的错误会在一定程度上解耦相邻的状态直接的联系。最终这个模型在准确度和L2距离的结果分别为0.576，0.652。 循环神经网络 [9] 这个模型的注重点在于模型对扩展域的自适应性的问题（即训练数据中不存在的槽类型即槽值）。其中，系统将用户叙述中的槽类型和槽值分别用&lt;slot>和&lt;value>来替代。由于对于每个叙述表示的都是在不同的槽类型和槽值之间的概率分布，因此若一个新的叙述的概率分布与系统的已知的叙述中的概率分布类似，则可以认为两者具有类似的的槽类型和槽值的关系。 通过上图的过程，我们可以得出 “Jamaican food”标记为 “s=food and v=jamaican”，若新的叙述为 “The Girton area” 其替换为&lt;slot>和&lt;value>的概率分布与前者类似，因此可以得出 “s=area and v=girton”。最终这个模型在准确度和L2距离的结果分别为0.646，0.534。 基于规则的模型 [10] 这篇文章设定了很多推理规则，并将规则看做是满足某些线性约束的特殊类型的多项式函数，马尔可夫贝叶斯多项式 (Markov Bayesian Polynomial, MBP)。在某些假设下，这个模型的求解过程可被视为整数线性规划问题 (Integer Linear Programming, ILP)，实验证明其具有很好的泛化能力。最终这个模型在准确度和L2距离的结果分别为0.610，0.556。 知识驱动的基于规则的模型 [11] 这篇文章认为目前的语言理解模型无法识别用户不关注的点，以及一些易产生歧义的信息，因此他们提出了一种基于知识的方法。对于每轮叙述，会基于机器的上一个动作act，用户的acts以及之前的act的概率分布猜想生成新的用户目标的概率分布猜想，类似于一个演绎推理的过程。最终这个模型在准确度和L2距离的结果分别为0.630，0.627。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [1] Overview of the NLPCC 2018 Shared Task: Spoken Language Understanding in Task-Oriented Dialog Systems[2] Learning Dialogue History for Spoken Language Understanding.[3] The Sogou Spoken Language Understanding System for the NLPCC 2018 Evaluation.[4] Frames: A Corpus for Adding Memory to Goal-Oriented Dialogue Systems.[5] A Frame Tracking Model for Memory-Enhanced Dialogue Systems.[6] The Dialog State Tracking Challenge Series: A Review, Learning End-To-End Goal-oriented Dialog.[7] Adobe-MIT submission to the DSTC 4 Spoken Language Understanding pilot task.[8] Markovian discriminative modeling for cross-domain dialog state tracking.[9] Robust Dialog State Tracking Using Delexicalised Recurrent Neural Networks and Unsupervised Adaptation.[10] A generalized rule based tracker for dialogue state tracking.[11] Knowledge-based dialog state tracking.]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>intent</tag>
        <tag>slot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Step to Establish the Blog]]></title>
    <url>%2F2018%2F11%2F01%2Ffirst_step%2F</url>
    <content type="text"><![CDATA[让我们搭一个美美的博客，一起写写写吧~~~ Requirement​ brew, hexo, Node.js Hexo项目12345$ hexo init # 新建博客目录$ hexo new "postname" # 生成postname.md文件$ hexo clean # 清空生成的网页$ hexo generate # 根据当前目录下文件生成静态网页$ hexo server # 启动服务器 通过访问localhost:4000可以在本地调试。文件目录source下的_posts中可以添加用户新增加的博客内容（Markdown语法）。 More info: Heox 修改主题1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 修改config.yml配置文件中的theme属性，将其设置为next。另外常见的Next主题中常见的属性：123456auto_excerpt: # 可通过 &lt;!-- more --&gt; 标签自动截断, 增加阅读全文按钮。 enable: true length: 150busuanzi_count: # 监听网页浏览量。 enable: true 添加新的导航栏1$ hexo new page tags # 添加tags标签页 修改source目录下的tags中的index.md如下： 12345---title: tagsdate: 2018-10-30 17:23:49type: &quot;tags&quot;--- 在菜单中添加链接。编辑config.yml配置文件中的menu属性，如下： 1234menu: home: / archives: /archives tags : /tags 部署到 Github修改config.yml配置文件中的deploy属性： 123deploy: type: git repo: https://github.com/test/test.github.io.git # github路径 通过下面的指令实现部署：12$ npm install hexo-deployer-git --save$ hexo deploy Google 收录博客网站 添加站点：用自己的 Google 帐号登陆 Webmaster Central。 验证站点: 将网站上的验证文件放在 source 文件下，在站点配置文件配置如下： 1skip_render: google10bb50e0b38f396b.html 产生 sitemap：借助 hexo-generator-sitemap 工具自动生成，并在config.yml里配置一下： 1npm install hexo-generator-sitemap --save 12sitemap: path: sitemap.xml 重新编译生成 1hexo generate]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
</search>
